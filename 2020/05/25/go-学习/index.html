<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>go 学习 | LIN is keeping learning</title><meta name="description" content="go 学习"><meta name="keywords" content="Go"><meta name="author" content="Lin"><meta name="copyright" content="Lin"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="go 学习"><meta name="twitter:description" content="go 学习"><meta name="twitter:image" content="http://yoursite.com/img/cat.jpg"><meta property="og:type" content="article"><meta property="og:title" content="go 学习"><meta property="og:url" content="http://yoursite.com/2020/05/25/go-%E5%AD%A6%E4%B9%A0/"><meta property="og:site_name" content="LIN is keeping learning"><meta property="og:description" content="go 学习"><meta property="og:image" content="http://yoursite.com/img/cat.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/05/25/go-%E5%AD%A6%E4%B9%A0/"><link rel="prev" title="Go语言细节" href="http://yoursite.com/2020/05/31/Go%E8%AF%AD%E8%A8%80%E7%BB%86%E8%8A%82/"><link rel="next" title="MySQL优化" href="http://yoursite.com/2020/05/16/MySQL%E4%BC%98%E5%8C%96/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://linbener.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"爱国,敬业,友善,诚实,自由,平等,和谐","fontSize":"12px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/tou.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#打包"><span class="toc-number">1.1.</span> <span class="toc-text">打包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工具链"><span class="toc-number">1.2.</span> <span class="toc-text">工具链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#依赖管理"><span class="toc-number">1.3.</span> <span class="toc-text">依赖管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型"><span class="toc-number">1.4.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量"><span class="toc-number">1.5.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值常量"><span class="toc-number">1.6.</span> <span class="toc-text">数值常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的转义字符"><span class="toc-number">1.7.</span> <span class="toc-text">常用的转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断类型是否相等"><span class="toc-number">1.8.</span> <span class="toc-text">判断类型是否相等</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构"><span class="toc-number">2.</span> <span class="toc-text">结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#循环"><span class="toc-number">2.1.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if"><span class="toc-number">2.2.</span> <span class="toc-text">if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch"><span class="toc-number">2.3.</span> <span class="toc-text">switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer"><span class="toc-number">2.4.</span> <span class="toc-text">defer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复杂类型"><span class="toc-number">3.</span> <span class="toc-text">复杂类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指针"><span class="toc-number">3.1.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构体"><span class="toc-number">3.2.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">3.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#slice"><span class="toc-number">3.4.</span> <span class="toc-text">slice</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建切片时的3个索引"><span class="toc-number">3.4.1.</span> <span class="toc-text">创建切片时的3个索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">3.5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#range"><span class="toc-number">3.6.</span> <span class="toc-text">range</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map映射"><span class="toc-number">3.7.</span> <span class="toc-text">map映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-number">3.8.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">3.9.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#接口类型"><span class="toc-number">3.10.</span> <span class="toc-text">接口类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌入类型"><span class="toc-number">3.11.</span> <span class="toc-text">嵌入类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stringers-结构体"><span class="toc-number">3.12.</span> <span class="toc-text">Stringers 结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误"><span class="toc-number">3.13.</span> <span class="toc-text">错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类型的本质"><span class="toc-number">3.14.</span> <span class="toc-text">类型的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#可见性和未公开的标识符"><span class="toc-number">3.15.</span> <span class="toc-text">可见性和未公开的标识符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发"><span class="toc-number">4.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步"><span class="toc-number">4.0.1.</span> <span class="toc-text">同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#竞争处理-锁住共享资源"><span class="toc-number">4.0.2.</span> <span class="toc-text">竞争处理 锁住共享资源</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#channel"><span class="toc-number">4.1.</span> <span class="toc-text">channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发模式"><span class="toc-number">4.2.</span> <span class="toc-text">并发模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#range-close"><span class="toc-number">4.3.</span> <span class="toc-text">range close</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#select"><span class="toc-number">4.4.</span> <span class="toc-text">select</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标准库"><span class="toc-number">5.</span> <span class="toc-text">标准库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#测试和性能"><span class="toc-number">6.</span> <span class="toc-text">测试和性能</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#testing包"><span class="toc-number">6.0.1.</span> <span class="toc-text">testing包</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/cat.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">LIN is keeping learning</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">go 学习</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-05-25 09:48:53"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-05-25</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-08-14 22:53:26"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-08-14</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>Go编译器是一行一行编译的，所以一行只能有一条语句</p>
<p>代码风格：运算符的两边加上一个空格 a + b </p>
<p>​                   一行最多只有80个字符，超过80字符要换行 ，使用逗号 , 换行。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><p>建构工程时查找包的目录，先是查找go语言的安装目录，然后再是用户的GOPATH工程目录</p>
<p>普通导入，<strong>远程导入</strong>  分布式版本控制系统DVCS分享代码，命名导入，_ 下划线导入 ，初始化包内的init函数。</p>
<h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><p>通配符 …   .</p>
<p>go vet  检测代码的常见错误</p>
<p>go fmt 代码格式化，非常有用 gofmt -w xx.go 把格式化的代码重新写入文件</p>
<p>阅读文档</p>
<p>go doc</p>
<p>go doc -http:=6060 浏览器查看文档</p>
<p>用户想要创建文档，遵守注释的规则即可，如果有大段的注释说明，要创建doc.go文件。</p>
<h3 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h3><p>gopkg.in vender</p>
<p>通过路径重写这种特性解决依赖第三方问题，需要设置GOPATH，</p>
<p>gb工具 管理第三方依赖 不需要设置GOPATH</p>
<p>构建工程需要进入工厂的根目录</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>bool</p>
<p>string   字符串的底层单个字符类型是uint8</p>
<p>int  int8  int16  int32  int64<br>uint uint8 uint16 uint32 uint64 uintptr</p>
<p>byte // uint8 的别名</p>
<p>rune // int32 的别名 // 代表一个Unicode码</p>
<p>float32 float64</p>
<p>complex64 complex128</p>
<p>变量在定义时没有明确的初始化时会赋值为_零值_。</p>
<p>零值是：</p>
<ul>
<li><p>数值类型为 <code>0</code>，</p>
</li>
<li><p>布尔类型为 <code>false</code>，</p>
</li>
<li><p>字符串为 <code>&quot;&quot;</code>（空字符串）。</p>
</li>
</ul>
<p>类型转换</p>
<p><strong>Go语言只支持显示的类型转换，不支持隐性的类型转换，如果没有显示地转换编译会报错。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i int &#x3D; 42</span><br><span class="line">var f float64 &#x3D; float64(i)</span><br><span class="line">var u uint &#x3D; uint(f)</span><br><span class="line"></span><br><span class="line">i :&#x3D; 42</span><br><span class="line">f :&#x3D; float64(i)</span><br><span class="line">u :&#x3D; uint(f)</span><br></pre></td></tr></table></figure>



<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量的定义与变量类似，只不过使用 <code>const</code> 关键字。</p>
<p>常量可以是字符、字符串、布尔或数字类型的值。</p>
<p>常量不能使用 <code>:=</code> 语法定义。</p>
<h3 id="数值常量"><a href="#数值常量" class="headerlink" title="数值常量"></a>数值常量</h3><p> 高精度的值</p>
<h3 id="常用的转义字符"><a href="#常用的转义字符" class="headerlink" title="常用的转义字符"></a>常用的转义字符</h3><p>\t \n \r <code>\&quot; \\</code> </p>
<h3 id="判断类型是否相等"><a href="#判断类型是否相等" class="headerlink" title="判断类型是否相等"></a>判断类型是否相等</h3><p>在GO语言中，判断两个类型是否相当，需要三个条件</p>
<p>这个三个条件是变量的字面量，底层类型，基础类型，底层类型是GO语言内部定义基础类型，而基础类型则是我们能看到的类型，包括我们自定义的类型，变量的三个方面都相等 ==判断才是true.</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>Go语言只有一种循环，就是for循环</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>跟 C 或者 Java 中一样，可以让前置、后置语句为空。基于此可以省略分号：C 的 <code>while</code> 在 Go 中叫做 <code>for</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum :&#x3D; 1</span><br><span class="line">	for sum &lt; 1000 &#123;</span><br><span class="line">		sum +&#x3D; sum</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>死循环，省略了循环条件，就是死循环</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> sqrt(-x) + <span class="string">"i"</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint(math.Sqrt(x))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟 for 一样，`if` 语句可以在条件之前执行一个简单的语句。</span></span><br><span class="line"><span class="comment">//由这个语句定义的变量的作用域仅在 if 范围之内。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 if 的便捷语句定义的变量同样可以在任何对应的 else 块中使用。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(x, n, lim <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;</span><br><span class="line">		<span class="keyword">return</span> v</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%g &gt;= %g\n"</span>, v, lim)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这里开始就不能使用 v 了</span></span><br><span class="line">	<span class="keyword">return</span> lim</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>一个结构体（<code>struct</code>）就是一个字段的集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch os :&#x3D; runtime.GOOS; os &#123;</span><br><span class="line">	case &quot;darwin&quot;:</span><br><span class="line">		fmt.Println(&quot;OS X.&quot;)</span><br><span class="line">	case &quot;linux&quot;:</span><br><span class="line">		fmt.Println(&quot;Linux.&quot;)</span><br><span class="line">	default:</span><br><span class="line">		&#x2F;&#x2F; freebsd, openbsd,</span><br><span class="line">		&#x2F;&#x2F; plan9, windows...</span><br><span class="line">		fmt.Printf(&quot;%s.&quot;, os)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>switch 的条件从上到下的执行，当匹配成功的时候停止。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">today := time.Now().Weekday()</span><br><span class="line">	<span class="keyword">switch</span> time.Saturday &#123;</span><br><span class="line">	<span class="keyword">case</span> today + <span class="number">0</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Today."</span>)</span><br><span class="line">	<span class="keyword">case</span> today + <span class="number">1</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Tomorrow."</span>)</span><br><span class="line">	<span class="keyword">case</span> today + <span class="number">2</span>:</span><br><span class="line">		fmt.Println(<span class="string">"In two days."</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"Too far away."</span>)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<p>没有条件的 switch 同 <code>switch true</code> 一样。</p>
<p><strong>这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t :&#x3D; time.Now()</span><br><span class="line">	switch &#123;</span><br><span class="line">	case t.Hour() &lt; 12:</span><br><span class="line">		fmt.Println(&quot;Good morning!&quot;)</span><br><span class="line">	case t.Hour() &lt; 17:</span><br><span class="line">		fmt.Println(&quot;Good afternoon.&quot;)</span><br><span class="line">	default:</span><br><span class="line">		fmt.Println(&quot;Good evening.&quot;)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>根据case的条件判断是否执行，只会执行其中的一个case或者default</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer 语句会延迟函数的执行直到上层函数返回。</p>
<p>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用</p>
<pre><code>defer fmt.Println(&quot;world&quot;)

fmt.Println(&quot;hello&quot;)</code></pre><p>延迟的函数调用<strong>被压入一个栈</strong>中。当函数返回时， 会按照<strong>后进先出</strong>的顺序调用被延迟的函数调用。</p>
<h2 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a>复杂类型</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>保存变量的内存地址</p>
<p><code>var p *int</code>  指向int类型的指针，零值是<code>nil</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i :&#x3D; 42</span><br><span class="line">p &#x3D; &amp;i  </span><br><span class="line">&#x2F;&#x2F;使用&amp;对指针进行赋值</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过指针改变i的值，间接引用i，也可以叫非直接引用</span><br><span class="line">*p&#x3D;21</span><br></pre></td></tr></table></figure>

<p>与C不同，Go没有指针运算</p>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>一个结构体（<code>struct</code>）就是一个字段的集合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Vertex struct &#123;</span><br><span class="line">	X int</span><br><span class="line">	Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(Vertex&#123;1, 2&#125;)</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;结构体字段使用点号来访问。</span><br><span class="line">	v:&#x3D;Vertex&#123;1,2&#125;</span><br><span class="line">	fmt.Println(v.X,v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>基于基础类型的结构体</p>
<p>type Duration int64</p>
<p><code>var time Duration</code></p>
<p><code>time=int64(1000)</code></p>
<p>以上这段代码会产生编译错误，虽然Duration是基于基础int64类型，但是实际上编译器认为Duration是一个<strong>独立的类型</strong>，不是int64类型，所以类型转换并不成功。</p>
<p>结构体指针</p>
<p>结构体字段可以通过结构体指针来访问。</p>
<p>通过指针间接的访问是透明的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Vertex struct &#123;</span><br><span class="line">	X int</span><br><span class="line">	Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	v :&#x3D; Vertex&#123;1, 2&#125;</span><br><span class="line">	p :&#x3D; &amp;v  &#x2F;&#x2F;p是*Vertex类型的指针</span><br><span class="line">	p.X &#x3D; 1e9</span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>结构体文法</strong></p>
<p>特殊的前缀 <code>&amp;</code> 返回一个指向结构体的指针。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Vertex struct &#123;</span><br><span class="line">	X, Y int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	v1 &#x3D; Vertex&#123;1, 2&#125;  &#x2F;&#x2F; 类型为 Vertex</span><br><span class="line">	v2 &#x3D; Vertex&#123;X: 1&#125;  &#x2F;&#x2F; Y:0 被省略</span><br><span class="line">	v3 &#x3D; Vertex&#123;&#125;      &#x2F;&#x2F; X:0 和 Y:0</span><br><span class="line">	p  &#x3D; &amp;Vertex&#123;1, 2&#125; &#x2F;&#x2F; 类型为 *Vertex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(v1, p, v2, v3) &#x2F;&#x2F;p的输出结果为&amp;&#123;1,2&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><code>var a [10]int</code></p>
<p>Go语言中数组的类型可以是内置类型，也可以是结构体</p>
<p>声明数组时 要给数组长度，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> array:&#x3D; [3]int&#123;10,11,12&#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;使用...代替数组的长度，编译器会根据后面的数据个数计算数组的长度</span><br><span class="line"> array1 :&#x3D;[...]int&#123;11,12&#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;下标1的元素为零值</span><br><span class="line">array2 :&#x3D;[3]int&#123;0:10,2:11&#125;</span><br><span class="line"></span><br><span class="line">var arr [5]int</span><br><span class="line">arr &#x3D; [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">arr :&#x3D; [5]int&#123;0:3, 4:6&#125;</span><br></pre></td></tr></table></figure>



<p>创建指针数组</p>
<p><strong>array:= [5]*int{0:new(int), 1:new(int)}</strong></p>
<p>此时array数组是一个指针数组，指针指向整型数据的地址</p>
<p><code>*array[0]=10</code></p>
<p>在Go语言中，数组是一个值，这意味着数组用在赋值操作中，变量名代表着整个数组，同样类型的数组可以赋值给另一个数组，这种赋值 属于深拷贝。</p>
<p>一个指针数组赋值给另一个指针数组，复制的只是指针指向数值，这说明赋值后的两个指针数组他们存储的地址不同，但是索引相同的地址，指向的数据值相同。</p>
<p>多维数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array [2][3]int</span><br><span class="line"></span><br><span class="line">array:&#x3D; [4][2]int&#123;1:&#123;0,1&#125;,2:&#123;2,4&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>因为数组是一个值，所有一维数组能给二维数组的一维赋值，反过来也可以。</p>
<p>函数间传递数组</p>
<p>如果传递的函数长度太长，因为函数参数传递是值传递，完整复制一个长度很长的数组需要消费内存，所有长度很长的数组，在函数声明时传递的参数应该是数组指针</p>
<p><strong>但是使用指针存在一个问题，指针会改变共享内存的值，但是切片不同。</strong></p>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p>切片是一种数据结构，它围绕着动态数组的概念构建，所以切片是可以按需扩大或缩小</p>
<p>切片是对数组的包装，故切片底层内存是连续分布的，能获得所以，迭代等数组好处。</p>
<p>切片的内部实现：</p>
<p><strong>[地址指针，长度，容量] 地址指针指向数组的首地址 长度是切片允许访问的元素个数，容量是切片允许增长到的元素个数。</strong></p>
<p><code>[]T</code> 是一个元素类型为 <code>T</code> 的 slice。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p :&#x3D; []int&#123;2, 3, 5, 7, 11, 13&#125;</span><br><span class="line">	fmt.Println(&quot;p &#x3D;&#x3D;&quot;, p)</span><br><span class="line">	</span><br><span class="line">for i :&#x3D; 0; i &lt; len(p); i++ &#123;</span><br><span class="line">	fmt.Printf(&quot;p[%d] &#x3D;&#x3D; %d\n&quot;, i, p[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>slice 可以重新切片，创建一个新的 slice 值指向相同的底层数组。</p>
<p><code>s[lo:hi]</code>  从lo 到 hi-1 ,不包括hi .</p>
<pre><code>p := []int{2, 3, 5, 7, 11, 13}
fmt.Println(&quot;p ==&quot;, p)
fmt.Println(&quot;p[1:4] ==&quot;, p[1:4]) //[3,5,7]

// 省略下标代表从 0 开始
fmt.Println(&quot;p[:3] ==&quot;, p[:3]) //[2,3,5]

// 省略上标代表到 len(s) 结束
fmt.Println(&quot;p[4:] ==&quot;, p[4:]) //[11,13]</code></pre><p><strong>构造slice</strong>  使用make函数，或者 切片字面量的方式创建切片</p>
<p>slice 由函数 <code>make</code> 创建。这会分配一个零长度的数组并且返回一个 slice 指向这个数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a :&#x3D; make([]int, 5)  &#x2F;&#x2F; len(a)&#x3D;5长度和容量都是5</span><br></pre></td></tr></table></figure>

<p>为了指定容量，可传递第三个参数到 <code>make</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b :&#x3D; make([]int, 0, 5) &#x2F;&#x2F; len(b)&#x3D;0, cap(b)&#x3D;5</span><br><span class="line"></span><br><span class="line">b &#x3D; b[:cap(b)] &#x2F;&#x2F; len(b)&#x3D;5, cap(b)&#x3D;5</span><br><span class="line">b &#x3D; b[1:]      &#x2F;&#x2F; len(b)&#x3D;4, cap(b)&#x3D;4</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;字面量</span><br><span class="line">slice :&#x3D;[]string&#123;&quot;red&quot;,&quot;green&quot;&#125; &#x2F;&#x2F;切面的长度和容量都是2</span><br><span class="line"></span><br><span class="line">slice1:&#x3D;[]string&#123;99:&quot;red&quot;&#125; &#x2F;&#x2F;长度和容量是100，99的元素值是red，其余的是零值</span><br></pre></td></tr></table></figure>

<p><strong>slice 的零值是 <code>nil</code>。</strong></p>
<p><strong>一个 nil 的 slice 的长度和容量是 0。</strong></p>
<p> <code>var slice []int</code>          <code>slice:= make([]int,0)</code> <code>slice:=[]int{}</code>            空切片</p>
<p><strong>切片访问超过长度的元素会报错。</strong></p>
<p><strong>注意数组和切片的区别，声明和创建数组需要指定数组的长度大小，而切片不需要。</strong></p>
<p>使用切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slice :&#x3D;[]int&#123;1,2,3,4,5&#125;&#x2F;&#x2F;长度和容量是5</span><br><span class="line"></span><br><span class="line">newslice :&#x3D;slice[1:3]   &#x2F;&#x2F;&#123;2,3&#125;，长度是2，容量是4&#x3D;(5-1)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注意slice newslice他们都是使用同一个底层数组，这意味着如果他们修改共享的数组部分，对方都能感受得到。</span><br></pre></td></tr></table></figure>

<p>对于以上的操作 底层数组容量是K的  新的切片<code>newslice[i:j]</code>  ，长度是 <code>**j-i**</code> 常量是 <strong><code>k-i</code></strong></p>
<p>向slice添加元素</p>
<p>通过内建函数append</p>
<p><code>func append(s []T, vs ...T) []T</code></p>
<p>它会处理新切片的长度和容量，每次append 长度和容量都会加上1</p>
<pre><code>a:= []int{1,2,3,4} 

b:=a[1,2] //长度是1，容量是3 {2}

b=append(b,6)   //append之后长度是2，容量是4  b={2,6}  a={1,2,6,3,4}

//a的结果会发生变化，是因为a和b的底层数组相同。</code></pre><p>而每次append之后除了切片的长度和容量+1外，底层数组也会自动增长，切片容量小于1000时，底层数组会倍增，但切片容量大于1000时，底层数组的增量因子位1.25，随着切片的容量变化，底层数组的增长算法也随之变化。</p>
<h4 id="创建切片时的3个索引"><a href="#创建切片时的3个索引" class="headerlink" title="创建切片时的3个索引"></a><strong>创建切片时的3个索引</strong></h4><p>第三个索引是用来控制新切片的容量的。目的是限制容量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a:&#x3D;[]int&#123;1,2,3,4,5&#125;</span><br><span class="line"></span><br><span class="line">b:&#x3D;a[1,3,4] &#x2F;&#x2F;长度是3-1&#x3D;2 ，容量是4-1&#x3D;3 ，如果限制的容量比可用容量还要大，那么将会发生错误，这个新切片的可用容量是5-1&#x3D;4，因为4&lt;&#x3D;4所以没有发生错误。</span><br></pre></td></tr></table></figure>



<p><strong>在旧切片上创建新切片时如果长度和容量相同，那么旧切片的底层数组和新切片的底层数组会发生分离，对新切片的操作，将会被旧切片感知。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a :&#x3D;[]int&#123;1,2,3,4,5&#125;</span><br><span class="line"></span><br><span class="line">b :&#x3D;a[2,3,3]  &#x2F;&#x2F;长度和容量都是3-2&#x3D;1，a切片的底层数组和b切片的底层数组分离</span><br></pre></td></tr></table></figure>



<p><strong>切片追加到另一个切片上。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1 :&#x3D;[]int&#123;1,2&#125;</span><br><span class="line"></span><br><span class="line">s2 :&#x3D;[]int&#123;3,4&#125;</span><br><span class="line"></span><br><span class="line">append(s1,s2...)  &#x2F;&#x2F;s1&#x3D;&#123;1,2,3,4&#125;</span><br></pre></td></tr></table></figure>



<p>多维切片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;slice :&#x3D;[][]int&#123;&#123;1&#125;,&#123;2,3&#125;&#125;&#96;</span><br></pre></td></tr></table></figure>



<p>在函数间传递切片只涉及切片本身结构，并不涉及切片相关联的底层数组。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>由于字符串底层是*byte指针，是连续的字节指针</p>
<p>因为UTF-8默认，中文字母用3个byte指针</p>
<p>可以用range 遍历，当遍历到中文时，索引会默认+3</p>
<p>或者字符串转换成rune切片，在rune类型下，单个中文字母占据一个空间单位，rune是Unicode的基础单位</p>
<h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p><code>for</code> 循环的 <code>range</code> 格式可以对 slice 或者 map 进行迭代循环。</p>
<p>range 函数<strong>第一个返回值为索引</strong>，<strong>第二个返回值是迭代的元素</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pow &#x3D; []int&#123;1, 2, 4, 8, 16, 32, 64, 128&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	for i, v :&#x3D; range pow &#123;</span><br><span class="line">		fmt.Printf(&quot;2**%d &#x3D; %d\n&quot;, i, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用下划线_ 忽略第一个返回值</p>
<p>for _ , v : = range pow</p>
<h3 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h3><p>映射是一个无序集合，所以每次迭代返回的键值对顺序都不一样，无序的原因是映射是使用了散列表。</p>
<p>映射的散列函数 键生成的散列值  <strong>散列值地位</strong>放在选择桶当中， <strong>散列值的高位</strong>存储在数组当中。</p>
<p>当放问键值对时，先访问选择桶，再访问数组，然后再访问字节数组。</p>
<p>映射的底层是两个数组结构来存储数据，第一个是数据结构是<strong>一个数组</strong>，存储<strong>选择桶的散列键的高八位值</strong>，第二数据结构是<strong>字节数组</strong>，用来<strong>存储键和值</strong>，先存储所以的键，再存储值。</p>
<p>创建映射 make 初始化</p>
<p>映射的键可以是内置类型也可以是某种结构体，<strong>只有这种类型能使用 == 运算符做比较。</strong></p>
<p><code>map1:=make(map[int]int)</code></p>
<p><code>map2:=map[]string{}</code>  值是字符串数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Vertex struct &#123;</span><br><span class="line">	Lat, Long float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;声明一个字符串到vertex值的映射</span><br><span class="line">var m map[string]Vertex</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    &#x2F;&#x2F;go语言使用make生成对象</span><br><span class="line">	m &#x3D; make(map[string]Vertex)  </span><br><span class="line">	</span><br><span class="line">	m[&quot;Bell Labs&quot;] &#x3D; Vertex&#123;</span><br><span class="line">		40.68433, -74.39967,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m[&quot;Bell Labs&quot;])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>map文法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var m &#x3D; map[string]Vertex&#123;</span><br><span class="line">	&quot;Bell Labs&quot;: Vertex&#123;</span><br><span class="line">		40.68433, -74.39967,</span><br><span class="line">	&#125;,</span><br><span class="line">	&#x2F;&#x2F;顶级的类型只有类型名，可以文法中的元素可以省略键名</span><br><span class="line">	&quot;Google&quot;:&#123;</span><br><span class="line">		37.42202, -122.08408,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>修改map</strong></p>
<p>m[key] = elem 赋值</p>
<p>elem=m[key] 获取</p>
<p>delete(m,key) 删除</p>
<p><strong>通过双赋值检测某个键存在，如果key存在,ok为true, 否则k 为false，对应的elem为其类型零值</strong></p>
<p><strong>elem, ok =m[key]</strong> </p>
<p><strong>映射在函数之间传递并不会创建副本，所以函数之内的改动，所以映射的引用都能察觉到变化。</strong></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><strong>函数也是值，意味着一个函数的返回值可以是另一个函数</strong></p>
<p>Go 函数可以是闭包的。闭包是一个函数值，它来自函数体的外部的变量引用。 函数可以对这个引用值进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。</p>
<p>例如，函数 <code>adder</code> 返回一个闭包。每个闭包都被绑定到其各自的 <code>sum</code> 变量上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func adder() func(int) int &#123;</span><br><span class="line">	sum :&#x3D; 0</span><br><span class="line">	return func(x int) int &#123;</span><br><span class="line">		sum +&#x3D; x</span><br><span class="line">		return sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	pos, neg :&#x3D; adder(), adder()</span><br><span class="line">	for i :&#x3D; 0; i &lt; 10; i++ &#123;</span><br><span class="line">		fmt.Println(</span><br><span class="line">			pos(i),</span><br><span class="line">			neg(-2*i),</span><br><span class="line">		)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Go语言中有两种接收者，<strong>值接收者 和 指针接收者</strong></p>
<p>GO语言允许使用值或者指针来调用方法，不必严格符合接收者的类型。</p>
<p>因为GO语言背后能做到值调用和指针调用的 引用。</p>
<p>至于使用值接收者还是指针接收者 不一定有接收者是否被修改决定，还有该类型的本质决定，比如文件类型</p>
<p>Go语言没有类，但是结构体类型上定义方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指针类型参数，改变指针指向的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//值类型参数，不改变原来值的大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">	fmt.Println(v.Abs())</span><br><span class="line">    </span><br><span class="line">    f := MyFloat(-math.Sqrt2)</span><br><span class="line">	fmt.Println(f.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注意方法和函数的区别</strong></p>
<p>函数</p>
<p>func name() ()  或者返回值是函数 func name() fun() ()</p>
<p>方法</p>
<p>func(struct) name() ()</p>
<h3 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h3><p>由一组方法定义的集合</p>
<p>如果某一个结构体实现了某一个接口的所以方法，那么结构体的值就能给接口变量赋值。</p>
<p>在函数参数是接口类型，那么在调用函数时，传递的值应该是地址，用func(&amp;XX)调用接口类型的函数，因为接口类型是引用类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果要对接口赋值，那么结构体要实现接口定义的方法</span></span><br><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">	Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a Abser</span><br><span class="line">	f := MyFloat(-math.Sqrt2)</span><br><span class="line">	v := Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">a = f  <span class="comment">// a MyFloat 实现了 Abser</span></span><br><span class="line">a = &amp;v <span class="comment">// a *Vertex 实现了 Abser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span></span><br><span class="line"><span class="comment">// 所以没有实现 Abser。</span></span><br><span class="line">a = v</span><br><span class="line"></span><br><span class="line">fmt.Println(a.Abs())</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"><span class="comment">//结构体MyFloat类型实现了Abs() float64签名的方法，</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">	X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体Vertex的指针 *Vertex实现了 Abs() float64签名的方法，所以给接口Abser赋值的是* Vertex，而不是Vertex结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>隐式接口</p>
<p>类型通过实现那些方法来实现接口。 没有显式声明的必要；所以也就没有关键字“implements“。</p>
<p>隐式接口解藕了实现接口的包和定义接口的包：互不依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">	Read(b []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Writer interface &#123;</span><br><span class="line">	Write(b []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">	Reader</span><br><span class="line">	Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="嵌入类型"><a href="#嵌入类型" class="headerlink" title="嵌入类型"></a>嵌入类型</h3><p>被嵌入的类型内的标识符上升到了外部类型的上，及外部类型能直接访问嵌入类型内的标识符。</p>
<p>内部类型实现的接口，外部类型也能直接调用接口类型内的相关方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type user struct&#123;</span><br><span class="line">name string,</span><br><span class="line">email string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type admin struct&#123;</span><br><span class="line">user,</span><br><span class="line">level string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var ad&#x3D;admin&#123;</span><br><span class="line">user :&#x3D;user&#123;</span><br><span class="line">name:&quot;lin&quot;,</span><br><span class="line">email:&quot;111@qq.com&quot;</span><br><span class="line">&#125;,</span><br><span class="line">level:&quot;l3&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;间接访问user的方法</span><br><span class="line">ad.user.notify()</span><br><span class="line">&#x2F;&#x2F;直接方法user的方法，这是因为user定义的字段提升到了admin级别</span><br><span class="line">ad.notify()</span><br></pre></td></tr></table></figure>

















<h3 id="Stringers-结构体"><a href="#Stringers-结构体" class="headerlink" title="Stringers 结构体"></a>Stringers 结构体</h3><p>一个普遍存在的接口是 [<code>fmt</code>]包中定义的 [<code>Stringer</code>]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Stringer interface &#123;</span><br><span class="line">    String() string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Stringer</code> 是一个可以用字符串描述自己的类型。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于实现了Java中对象的string方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"%v (%v years)"</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := Person&#123;<span class="string">"Arthur Dent"</span>, <span class="number">42</span>&#125;</span><br><span class="line">	z := Person&#123;<span class="string">"Zaphod Beeblebrox"</span>, <span class="number">9001</span>&#125;</span><br><span class="line">	fmt.Println(a, z)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常函数会返回一个错误，查看它是否为空，为nil函数调用成功，不为nil函数调用失败</p>
<p>结构体重写Error方法为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	When time.Time</span><br><span class="line">	What <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">"at %v, %s"</span>,</span><br><span class="line">		e.When, e.What)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Reader接口</p>
<p><code>io</code> 包指定了 <code>io.Reader</code> 接口， 它表示从数据流结尾读取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (T) Read(b []byte) (n int, err error)</span><br></pre></td></tr></table></figure>



<h3 id="类型的本质"><a href="#类型的本质" class="headerlink" title="类型的本质"></a>类型的本质</h3><p>GO语言的引用类型有 <strong>切片 映射 通道 接口 函数类型</strong></p>
<p>声明上述类型时，创建的变量叫做 标头</p>
<p>引用类型存在标头值 指向底层的数据结构</p>
<h3 id="可见性和未公开的标识符"><a href="#可见性和未公开的标识符" class="headerlink" title="可见性和未公开的标识符"></a>可见性和未公开的标识符</h3><p>如果一个标识符是小写字母开头，那么这个标识符就是未公开的，及包外的代码不可见。</p>
<p>如果一个标识符是以大写字母开头，那么标识符是可见的，包外的代码能看见。</p>
<p>习惯，工厂函数在GO语言被命名为New</p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>逻辑处理器，GO语言使用逻辑处理器获得多CPU处理。</p>
<p>runtime 包的 <code>runtime.GOMAXPROCS(1)</code>  分配一个逻辑处理器给调度器使用。</p>
<p>GO语言设置的逻辑处理器大于1，只有在计算机属于多核范畴才起作用。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>具体使用到的方法和变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;等待线程完成计算器</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line">&#x2F;&#x2F;等待两个线程</span><br><span class="line">wg.Add(2)</span><br><span class="line">&#x2F;&#x2F;线程等待</span><br><span class="line">wg.Wait()</span><br><span class="line">&#x2F;&#x2F;通知主线程，副线程完成</span><br><span class="line">wg.Done()</span><br></pre></td></tr></table></figure>



<h4 id="竞争处理-锁住共享资源"><a href="#竞争处理-锁住共享资源" class="headerlink" title="竞争处理 锁住共享资源"></a>竞争处理 锁住共享资源</h4><p><strong>GO语言命令能检测出竞争代码</strong></p>
<p>go build -race     x.go</p>
<p>./x //允许代码</p>
<p>输出竞争片段</p>
<p><strong>原子函数 sync/atomic</strong></p>
<p>atomic.AddInt64(&amp;,n)  //&amp;+n</p>
<p>atomic.LoadInt64() atomic.StoreInt64() //安全的读写操作</p>
<p><strong>互斥锁</strong> mutex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mutex sync.Mutex</span><br><span class="line"></span><br><span class="line">mutex.Lock()</span><br><span class="line"></span><br><span class="line">mutex.Unlock()</span><br></pre></td></tr></table></figure>



<p>协程：轻量级的线程</p>
<p>GO语言线程之间通过消息传递方式实现线程通信，而不是使用共享内存的方式实现线程通信。</p>
<p>利用管道的方式实现消息传递。</p>
<p>goroutine 是GO运行时环境管理的协程</p>
<p>go 关键词启动一个协程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go f(x, y, z)</span><br></pre></td></tr></table></figure>

<p>goroutine 在相同的地址空间中运行，因此访问共享内存必须进行同步。</p>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel 是有类型的管道，可以用 channel 操作符 <code>&lt;-</code> 对其发送或者接收值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    &#x2F;&#x2F; 将 v 送入 channel ch。</span><br><span class="line">v :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收，并且赋值给 v。</span><br></pre></td></tr></table></figure>



<p>channel必须要创建</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;创建int类型的管道,chan是管道关键词</span><br><span class="line">ch :&#x3D; make(chan int)</span><br></pre></td></tr></table></figure>

<p>默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步。</p>
<p>缓存管道</p>
<p>​    <code>c := make(chan int, 2)</code> <code>make</code> 提供第二个参数作为缓冲长度来初始化一个缓冲</p>
<p>向缓冲 channel 发送数据的时候，只有在缓冲区满的时候才会阻塞。当缓冲区清空的时候接受阻塞。</p>
<p><strong>向缓存区满的管道 添加 数据 会造成协程 死锁</strong></p>
<h3 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h3><p>runner pool work</p>
<p>三个包和协程处理有关，都是采用通道传递信息。</p>
<h3 id="range-close"><a href="#range-close" class="headerlink" title="range close"></a>range close</h3><p>发送者可以 <code>close</code> 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：<strong>当没有值可以接收并且 channel 已经被关闭，那么经过之后，ko为设为false</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">v, ok :&#x3D; &lt;-ch</span><br></pre></td></tr></table></figure>



<p>循环 <code>for i := range c</code> 会不断从 channel 接收值，直到它被关闭。</p>
<p>只有发送者才能关闭 channel，而不是接收者。向一个已经关闭的 channel 发送数据会引起 panic。 <strong>还要注意：</strong> channel 与文件不同；通常情况下无需关闭它们。只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭，例如中断一个 <code>range</code>。</p>
<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><code>select</code> 语句使得一个 goroutine 在多个通讯操作上等待。</p>
<p><code>select</code> 会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。</p>
<p>默认选择</p>
<p>当 <code>select</code> 中的其他条件分支都没有准备好的时候，<code>default</code> 分支会被执行。</p>
<p>为了非阻塞的发送或者接收，可使用 <code>default</code> 分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select &#123;</span><br><span class="line">case i :&#x3D; &lt;-c:</span><br><span class="line">    &#x2F;&#x2F; 使用 i</span><br><span class="line">default:</span><br><span class="line">    &#x2F;&#x2F; 从 c 读取会阻塞</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>记录和日志</p>
<p>log包</p>
<p>编码和解码</p>
<p>GO语言中序列化都是转变成json格式。</p>
<p>输入和输出</p>
<h2 id="测试和性能"><a href="#测试和性能" class="headerlink" title="测试和性能"></a>测试和性能</h2><p>GO语言中测试文件通常以 <strong><code>_test.go</code></strong>结尾</p>
<h4 id="testing包"><a href="#testing包" class="headerlink" title="testing包"></a>testing包</h4><p>基础单元测试</p>
<p>go test -v</p>
<p>表组测试</p>
<p>基准测试</p>
<p>模拟调用</p>
<p>net/http //模拟网络状态</p>
<p>示例</p>
<p>在godoc文档中提供实例的文件</p>
<p>基准测试</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/05/25/go-%E5%AD%A6%E4%B9%A0/">http://yoursite.com/2020/05/25/go-%E5%AD%A6%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="/img/cat.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/05/31/Go%E8%AF%AD%E8%A8%80%E7%BB%86%E8%8A%82/"><img class="prev_cover lazyload" data-src="/img/cat.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Go语言细节</div></div></a></div><div class="next-post pull_right"><a href="/2020/05/16/MySQL%E4%BC%98%E5%8C%96/"><img class="next_cover lazyload" data-src="/img/cat.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MySQL优化</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/07/08/Go-Web/" title="Go-Web"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-08</div><div class="relatedPosts_title">Go-Web</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/12/go-学习2/" title="go 学习2"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-12</div><div class="relatedPosts_title">go 学习2</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><script id="utterances_comment" src="https://utteranc.es/client.js" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script><script>var themeNow = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
document.getElementById('utterances_comment').setAttribute('theme',themeNow)

function utterancesTheme () {
var theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
const message = {
  type: 'set-theme',
  theme: theme
};
const iframe = document.querySelector('.utterances-frame');
iframe.contentWindow.postMessage(message, 'https://utteranc.es');
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Lin</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script></body></html>