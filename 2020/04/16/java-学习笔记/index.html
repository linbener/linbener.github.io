<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java 学习笔记 | LIN is keeping learning</title><meta name="description" content="java 学习笔记"><meta name="keywords" content="program"><meta name="author" content="Lin"><meta name="copyright" content="Lin"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java 学习笔记"><meta name="twitter:description" content="java 学习笔记"><meta name="twitter:image" content="http://yoursite.com/img/cat.jpg"><meta property="og:type" content="article"><meta property="og:title" content="java 学习笔记"><meta property="og:url" content="http://yoursite.com/2020/04/16/java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><meta property="og:site_name" content="LIN is keeping learning"><meta property="og:description" content="java 学习笔记"><meta property="og:image" content="http://yoursite.com/img/cat.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/04/16/java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><link rel="prev" title="java集合" href="http://yoursite.com/2020/04/17/java%E9%9B%86%E5%90%88/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://linbener.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"爱国,敬业,友善,诚实,自由,平等,和谐","fontSize":"12px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/tou.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">29</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">14</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java核心技术"><span class="toc-number">1.</span> <span class="toc-text">Java核心技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#一"><span class="toc-number">1.1.</span> <span class="toc-text">一</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#反射"><span class="toc-number">1.1.1.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#接口"><span class="toc-number">1.1.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内部类"><span class="toc-number">1.1.3.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代理proxy"><span class="toc-number">1.1.4.</span> <span class="toc-text">代理proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常Throwable"><span class="toc-number">1.1.5.</span> <span class="toc-text">异常Throwable</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#日志"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">日志</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#部署Java应用程序"><span class="toc-number">1.1.6.</span> <span class="toc-text">部署Java应用程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-8实战"><span class="toc-number">2.</span> <span class="toc-text">Java 8实战</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#行为参数化"><span class="toc-number">2.0.1.</span> <span class="toc-text">行为参数化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lambda表达式"><span class="toc-number">2.0.2.</span> <span class="toc-text">lambda表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#流-Stream"><span class="toc-number">2.0.3.</span> <span class="toc-text">流 Stream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Collectors方法"><span class="toc-number">2.0.4.</span> <span class="toc-text">Collectors方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行流"><span class="toc-number">2.0.5.</span> <span class="toc-text">并行流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认方法"><span class="toc-number">2.0.6.</span> <span class="toc-text">默认方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Optional"><span class="toc-number">2.0.7.</span> <span class="toc-text">Optional</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新的日期函数"><span class="toc-number">2.0.8.</span> <span class="toc-text">新的日期函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高阶函数-科里化"><span class="toc-number">2.0.9.</span> <span class="toc-text">高阶函数 科里化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java9新特性"><span class="toc-number">3.</span> <span class="toc-text">Java9新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java10新特性"><span class="toc-number">4.</span> <span class="toc-text">java10新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java11新特性"><span class="toc-number">5.</span> <span class="toc-text">Java11新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java12新特性"><span class="toc-number">6.</span> <span class="toc-text">Java12新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java13新特性"><span class="toc-number">7.</span> <span class="toc-text">Java13新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java14新特性"><span class="toc-number">8.</span> <span class="toc-text">java14新特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java15新特性"><span class="toc-number">9.</span> <span class="toc-text">java15新特性</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/cat.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">LIN is keeping learning</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">java 学习笔记</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-04-16 15:52:19"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-04-16</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-09-09 11:27:46"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-09-09</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="Java核心技术"><a href="#Java核心技术" class="headerlink" title="Java核心技术"></a>Java核心技术</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.nanoTime(); <span class="comment">// 当前正在运行的虚拟机高分辨率的时间源，单位纳秒 1 ns=10的负9次方秒</span></span><br><span class="line">System.currentTimeMillis(); <span class="comment">//当前时间于UTC的时间差，以毫秒为单位  1 ms=10的负3次方秒</span></span><br><span class="line"></span><br><span class="line">它们的返回的时间值并不精确，具体看情况</span><br></pre></td></tr></table></figure>



<p>Unicode编码  char类型 不推荐使用的类型，推荐使用String</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">       <span class="comment">//生成格式化的字符串。 </span></span><br><span class="line">String str=String.format(<span class="string">"%d , %s"</span>,dog.getAge(),dog.getName());</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>



<p>Math 常用的数学类包</p>
<p>位运算符  &amp; and ;|or ; ~ not ; 向上的小箭头 异或  ；与逻辑运算不同，位运算没有 短路 的方式求值</p>
<p>左移右移运算符 &lt;&lt; &gt;&gt;       <strong>这些运算符可以进行掩码运算</strong></p>
<p>子网掩码是用来判断两台计算机是否处于同一个子网络，他们的IP地址和子网掩码 进行 按位AND运算，如果结果相同，他们就处于同一个子网络。</p>
<p>‘&gt;&gt;&gt;’ 运算符也会用0填充高位，但不&gt;&gt;不同，它会用符号位填充高位</p>
<p>字符串的空串判断 和为空判断  空串的长度为0 ，为空NULL</p>
<p>Java字符串是由char值序列构成。</p>
<p><strong>码点 和代码单元</strong></p>
<p>char数据类型是一个采用UTF-16编码表示的<strong>Unicode码点</strong>的<strong>代码单元</strong>。</p>
<p>遍历字符串的每一个字符，不推荐使用charAt()方法，因为太底层了，它返回的是代码单元，而不是码点，码点可以看作一个字符，但有些字符需要用两个代码单元表示，而它只是一个码点。</p>
<p>字符串length方法返回的是代码单元的个数，而不是我们认为的字符个数，如果没有特殊的用两个代码单元表示的字符，那么它就可以用，有特殊字符存在就要格外小心。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String string=<span class="string">"lin lin"</span>;</span><br><span class="line">       <span class="keyword">int</span> i=string.codePointCount(<span class="number">0</span>,string.length());</span><br><span class="line">       System.out.println(<span class="string">"str is length"</span>+i);</span><br><span class="line">       System.out.println( <span class="string">"不太严谨 "</span>+string.length());</span><br><span class="line">       <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> j=string.offsetByCodePoints(<span class="number">0</span>, k);返回的是从<span class="number">0</span>到K的码点索引</span><br><span class="line">       System.out.println(j);</span><br><span class="line">       <span class="keyword">int</span> n=string.codePointAt(j); <span class="comment">//返回的是给定位置的码点位置</span></span><br><span class="line">       System.out.println(n);</span><br></pre></td></tr></table></figure>



<p>标准输出流  System.out</p>
<p>标准输入流 System.in  读取输入要用到Scanner对象</p>
<p>文件的输入和输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner in=<span class="keyword">new</span> Scanner(Paths.get(<span class="string">"test.txt"</span>),<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">PrintWriter out=<span class="keyword">new</span> PrintWriter(<span class="string">"my.txt"</span>,<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>



<p>大数值 java.math  BigInteger BigDecimal</p>
<p>数组操作  Arrays类</p>
<p>类路径 jar文件是使用ZIP格式组织文件和子目录的。</p>
<p>例如 / home / user / classdir。 需要注意 ， 这个目录是包树状结构的基目录。 如果希望将 com . horstmann . corejava . Employee 类添加到其中 ， 这个 Employee . class类文件就必须位于子目录 / home / user / classdir / com / horstmann / corejava 中。</p>
<p>. 代表当前目录，Java SE6开始目录也支持使用通配符 ，*</p>
<p>设置类路径指令 -classpath 或-cp</p>
<p>文档注释 生成javadoc文档</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**    </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@param</span> <span class="meta">@return</span> <span class="meta">@throws</span> <span class="comment">//方法注释</span></span><br><span class="line"></span><br><span class="line">通用注释</span><br><span class="line"><span class="meta">@author</span> <span class="meta">@version</span> <span class="meta">@since</span> <span class="meta">@deprecated</span>(取代注释，不推荐使用的方法，过时的方法)</span><br><span class="line"><span class="meta">@see</span> <span class="meta">@link</span> 链接注释</span><br><span class="line"></span><br><span class="line">包和概述注释   就需要在每一个包目录中添加一个单独的文件 </span><br><span class="line"><span class="number">1</span> 要想产生包注释 ， 提供一个以 <span class="keyword">package</span> . html 命名的 HTML 文件。在标记&lt; body &gt; — &lt; / body &gt; 之间的所有文本都会被抽取出来。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 提供一个以 <span class="keyword">package</span>-info.java 命名的 Java 文件 。 这个文件必须包含一个初始的以 / **</span><br><span class="line">和 * / 界定的 Javadoc 注释 ， 跟随在一个包语句之后</span><br><span class="line">。 它不应该包含更多的代码或注释 。</span><br></pre></td></tr></table></figure>

<p>注释的抽取，假设HTML文件存在在docs目录下</p>
<p>1 进入到包到抽取注释包的目录下</p>
<p>2 指令命令</p>
<p>javadoc -d docs nameOfPackage1,[nameOfPackage2….]</p>
<p>3 如果文件在默认包里 可以执行 javadoc -d docs *.java</p>
<p>装箱 拆箱机制</p>
<p>要避免装箱，因为这会严重损耗性能。</p>
<p>基本数据类型(不包括string)  和 对象类型(封装类)</p>
<p>int是基本数据类型，Integer是对int进行了封装的一个类，称为包装类。</p>
<p><strong>包装类的值是不可变的，一旦构建了包装类，就如同String一样，它们的值不会改变。</strong>   </p>
<p>Integer   是比int   更高级的数据类型</p>
<p> Int   一般做为数值参数就够了<br> Integer   一般做类型转换的时候用的较多</p>
<p>装箱就是把原始基本的数据类型包装为对象类型，<br>拆箱表示将对象类型拆分为基本的数据类型。</p>
<p>装箱后的值的本质就是把原始类型包装起来，并保存在堆里。因此<br>装箱后的值需要更多的内存空间。并需要额外的内存搜索来获取被包裹的原始值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line">Integer total=<span class="number">99</span>;  <span class="comment">//Integer.valueOf(99) 反编译执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">int</span> price=total;   <span class="comment">// total.intValue();</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@Override</span></span></span><br><span class="line"><span class="comment">public int intValue() &#123;</span></span><br><span class="line"><span class="comment">    return value;  直接返回值</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<p>参数可变类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String... args)&#123; ...代表可以接受多个String类型的变量，类似String[] args</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>枚举类</strong></p>
<p>比较枚举类相等永远不要用equals ，而是用 == 判断。</p>
<p>常用的方法有toString valueOf values</p>
<p>枚举类的用途有很多，常用的是用于替换 三层if判断 ，采用创建一个枚举类，执行枚举类相应的实现的方法。</p>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class dogReflect =dog.getClass();</span><br><span class="line"></span><br><span class="line">String path=<span class="string">"com.test.Dog"</span>;</span><br><span class="line">Class dogre=Class.forName(path);</span><br><span class="line"></span><br><span class="line">Class dogres=Dog<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">     Constructor[]constructors= dogReflect.getConstructors();</span><br><span class="line"></span><br><span class="line">     Method[] methods=dogReflect.getMethods(); <span class="comment">//返回PUBLIC域的类的函数</span></span><br><span class="line">     Method[] methods1=dogReflect.getDeclaredMethods();</span><br><span class="line">     </span><br><span class="line">     Field[] fields=dogReflect.getDeclaredFields();<span class="comment">//返回所有域的类的属性</span></span><br><span class="line"></span><br><span class="line">     Class[] interfaces=dogReflect.getInterfaces();</span><br><span class="line"></span><br><span class="line">     System.out.println(constructors.length);</span><br><span class="line">     </span><br><span class="line">     Constructor constructor=constructors[<span class="number">2</span>];</span><br><span class="line">     Dog dog1= (Dog)constructor.newInstance(); <span class="comment">//实例化dog对象</span></span><br><span class="line"></span><br><span class="line">     Method method=dogReflect.getMethod(<span class="string">"getFlag"</span>);</span><br><span class="line">     System.out.println(method.invoke(dog1));<span class="comment">//调用dog的非静态方法，需要传入dog实例</span></span><br><span class="line"></span><br><span class="line"> Method method1=dogReflect.getDeclaredMethod(<span class="string">"setI"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>)</span>; <span class="comment">//调用Dog的静态方法</span></span><br><span class="line">     method1.invoke(dogReflect,<span class="number">2</span>); <span class="comment">//因为是静态方法，所以第一个参数可以不是dog的实例，而是class</span></span><br><span class="line">     System.out.println(Dog.getI());</span><br><span class="line"></span><br><span class="line">Field field=dogReflect.getDeclaredField(<span class="string">"age"</span>); <span class="comment">//访问private属性</span></span><br><span class="line">     field.setAccessible(<span class="keyword">true</span>); <span class="comment">//设置访问权限，不然会出错</span></span><br><span class="line">     field.set(dog1,<span class="number">12</span>); <span class="comment">//调用set方法，传入实例对象和值</span></span><br><span class="line">     Field field1=dogReflect.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">     field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">     field1.set(dog1,<span class="string">"KJ"</span>);</span><br><span class="line">     System.out.println(dog1);</span><br></pre></td></tr></table></figure>

<p>利用反射分析和创建实例对象中，方法大多数会抛出异常，用字节码文件直接创建实例对象的方法已经被抛弃了</p>
<p>即<code>class.newInstance</code>被抛弃了，现在只能用<code>constructor.newInstance()</code> 。</p>
<p>反射调用一般分为3个步骤：</p>
<ul>
<li>得到要调用类的class</li>
<li>得到要调用的类中的方法(Method) 如果调用的方法需要传入实例对象，那么需要class.getConstructor()创建一个默认的初始化方法，并constructor.newInstance()实例化。如果调用的方法是静态方法，那么只需要传入字节码class文件,后面的参数是传入方法需要的参数。</li>
<li>方法调用(invoke)  并传入值。</li>
</ul>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在Java中接口是对类一组需求的描述，继承接口的类，必须履行接口规定的职责。</p>
<p>比如<code>Arrays.sort()</code> 可以叫对象数组进行排序，前提是对象要实现Comparable接口, 该接口的职责就是<code>compareTo()</code>方法。</p>
<p>compareTo传入的对象是Object类型的，你需要用到类型转换成具体的类型，但是可以给接口提供一个泛型参数，规定具体的对象，这一点让你无需进行显示的类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Employee</span>&gt;//提供具体的泛型参数</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Employee other)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Double.compare(<span class="keyword">this</span>.salary,other.getSalary())</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接口的方法域为public ;而接口的域，即常量设置为public static final</p>
<p>在Java8中接口增加了 静态方法 和 默认方法，这两种方法都要在接口给出实现，虽然有违接口的抽象设计原则，但实际上库中已经有成对的例子了。</p>
<p>比如 <code>Path.get(String first,String... more)</code> </p>
<p>默认方法，在方法前加上default修饰符。</p>
<p>接口的常见用途</p>
<p>回调 </p>
<p>常见的接口Comparator 人工比较器，优先级大于Comparable接口，如果一个对象继承了这个两个接口，调用sort方法时，优先调用Comparator。</p>
<p>Cloneable接口，实现的是<code>clone()</code>,一般用于创建深拷贝。</p>
<p><code>Comparator.comparing( )</code> 这个静态方法，根据传入的函数生成一个比较器。</p>
<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>共有内部类  内部类的语法规则复制，内部类内部有个隐含的引用指向外部类，这使得内部类可以访问外部类的方法或者属性。使用这个规则的语法是，<code>OuterClassName.this</code>这个是引用。</p>
<p>内部类如果是共有的，那么可以为任意一个外部类实例对象创建内部类实例对象。</p>
<p>规则：<code>OuterClassName.InnerClassName var=new outer.new innerclass()</code> outer是外部类的实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InneClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InneClass</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setS</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">innerclass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> t;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">innerclass</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">result</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//内部类使用外部类的属性和方法</span></span><br><span class="line"><span class="comment">//            return t*s;  </span></span><br><span class="line"><span class="comment">//            return  t*InneClass.this.getS();  </span></span><br><span class="line">            <span class="keyword">return</span> t*InneClass.<span class="keyword">this</span>.s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InneClass test=<span class="keyword">new</span> InneClass(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//为外部类实例创建一个内部类</span></span><br><span class="line">        InneClass.innerclass innerclass=test.<span class="keyword">new</span> innerclass(<span class="number">5</span>); </span><br><span class="line">        <span class="keyword">int</span> result= innerclass.result();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类的声明的静态域必须是final ,内部类不能有静态方法。</p>
<p>局部内部类</p>
<p><strong>在方法内部的类，能访问与方法同处同一个域的变量与其他的方法，也能访问在方法域内的局部变量。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InneClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InneClass</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">result</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">innerclass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//方法内部的类能访问InnerClass类。</span></span><br><span class="line"><span class="comment">//            return t*s;</span></span><br><span class="line"><span class="comment">//            return t*InneClass.this.s;</span></span><br><span class="line">                InneClass.<span class="keyword">this</span>.setS(<span class="number">3</span>);</span><br><span class="line">                <span class="keyword">return</span> t * InneClass.<span class="keyword">this</span>.getS();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> innerclass().result();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InneClass test=<span class="keyword">new</span> InneClass(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">int</span> a= test.result(<span class="number">6</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名内部类</p>
<p>静态内部类</p>
<p><strong>使用内部类无论是共有的，匿名的，还是局部的，都是为了把类隐藏在另一个类的内部，<em>而且这些内部类都创建了一个指向外部类的引用。</em></strong></p>
<p><strong>如果内部类无需创建指向外部类的引用，可以把内部类设置成static。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InneClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pair <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">int</span> y;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Pair&#123;"</span> +</span><br><span class="line">                    <span class="string">"x="</span> + x +</span><br><span class="line">                    <span class="string">", y="</span> + y +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        InneClass test=<span class="keyword">new</span> InneClass();</span><br><span class="line">        Pair pair=test.set();</span><br><span class="line">        pair.setX(<span class="number">4</span>);</span><br><span class="line">        pair.setY(<span class="number">5</span>);</span><br><span class="line">        System.out.println(pair);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="代理proxy"><a href="#代理proxy" class="headerlink" title="代理proxy"></a>代理proxy</h4><p>利用代理可以在运行时创建一个实现一组接口的新类。一般用在编译时无法确定使用那个接口时才有必要使用。</p>
<p>1.基于JDK的动态代理</p>
<p>2.基于CGILB的动态代理</p>
<p><strong>基于JKD的动态代理被代理的类是要继承接口的</strong>，这一点非常重要，<strong>用代理的方式生成的对象需要用接口接受</strong>，如果用具体对象，将会发生转换异常。代理类需要实现<code>InvocationHandler</code>接口的方法，用<code>Proxy.newProxyInstance()</code>生成代理的类，有三个参数，第一个是代理类的加载器，第二个参数是被代理类继承的接口class文件，第三个参数即是代理类的实例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"很高兴认识你，我叫"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonProxy</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始代理"</span>);</span><br><span class="line">        Object person=method.invoke(<span class="keyword">this</span>.person,args);</span><br><span class="line">        System.out.println(<span class="string">"结束代理"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Person) person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person=<span class="keyword">new</span> Person();</span><br><span class="line">        PersonProxy handler=<span class="keyword">new</span> PersonProxy(person);</span><br><span class="line">        <span class="comment">//要用接口实现接受代理生成的对象，这也是JDK要求被代理类一定要继承接口的原因</span></span><br><span class="line">        Hello o= (Hello)    Proxy.newProxyInstance(handler.getClass().getClassLoader(),person.getClass().getInterfaces(),handler);</span><br><span class="line">        o.hello(<span class="string">"lin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>而基于CGILB代理的类不需要继承接口，也能实现代理，引入CGLIB的jar包和asm包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是一只迷人的小猫咪，名字叫"</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="comment">//o是被代理的类    </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始代理"</span>);</span><br><span class="line">        Object o1=methodProxy.invoke(o,objects);</span><br><span class="line">        System.out.println(<span class="string">"结束代理！"</span>);</span><br><span class="line">        <span class="keyword">return</span> o1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer=<span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(Cat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CatProxy());</span><br><span class="line">        Cat cat= (Cat) enhancer.create();</span><br><span class="line">        cat.hello(<span class="string">"mimi"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="异常Throwable"><a href="#异常Throwable" class="headerlink" title="异常Throwable"></a>异常Throwable</h4><p>带有资源的try语句</p>
<p><code>try( open resource   ){ }</code></p>
<p>堆栈轨迹元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Throwable t=<span class="keyword">new</span> Throwable();</span><br><span class="line">StackTraceElement[] f=t.getStackTrace();</span><br><span class="line"><span class="keyword">for</span> (StackTraceElement s:f) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>断言，默认情况下断言被禁止，</p>
<p>运行程序时可以用命令-enableassertions 或-ea启用断言</p>
<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p><strong>java.util.logging</strong></p>
<p>基本日志</p>
<p><code>全局日志器Logger.getGlobal().info(&quot;hello&quot;);</code> 用来代替<code>System.out.println();</code></p>
<p>高级日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger mylogger=Logger.getLogger(<span class="string">"com.test.CatProxy.java"</span>);</span><br><span class="line"></span><br><span class="line">mylogger.log(Level.INFO,<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>



<h4 id="部署Java应用程序"><a href="#部署Java应用程序" class="headerlink" title="部署Java应用程序"></a>部署Java应用程序</h4><p>创建jar文件    jar cvf jar_name file1…</p>
<p>清单文件 描述归档特征的清单文件MANIFEST.MF ，位于jar文件的一个特殊目录META-INF子目录中</p>
<p>最简单的清单文件是 Manifest - Version : 1.0</p>
<p>可执行的jar文件 命令e指定程序的入口点，集通常需要在调用Java程序加载器指定的类</p>
<p>jar cvfe My.jar com.my.mn.MainAppClass file1…   入口类不需要.class扩展名</p>
<p>资源与密封</p>
<p>默认情况下Jar的包是没有密封的，包密封以保证不会有其他的类加入其中。</p>
<p>清单文件增加一节，指定密封这个包</p>
<p>Name: com/mycom/util/</p>
<p>Sealed: false</p>
<p>分支-合并框架</p>
<h2 id="Java-8实战"><a href="#Java-8实战" class="headerlink" title="Java 8实战"></a>Java 8实战</h2><p>特性chuang’j</p>
<h4 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h4><p>将对象的行为动作作为函数传递给方法，Object::method   方法的引用，可以将对象的方法作为参数传递。</p>
<p>演化</p>
<p>行为抽象为一个函数接口，在Java 8中引入函数接口概念，@FunctionalInterface, 该函数接口和普通的接口没有很大的区别，<strong>唯一的区别就是该接口只有一个抽象方法</strong>，该方法的返回值类型不受限。</p>
<p>如何把行为作为参数传递，经过了三次的思路演化，首先在Java里，万物结对象，而对象的行为在表达中可以视为一个方法，所以Java中行为及方法。</p>
<p>把方法传递给作为参数传递给另一个方法，如何实现？</p>
<p>思路：方法抽象为一个函数接口，实现函数接口，并传递函数接口。</p>
<p>实例： 筛选苹果，苹果有重量，颜色，产地，更具筛选行为的不同，选出不同的苹果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">handle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//筛选苹果的行为</span></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(List&lt;Apple&gt; list, handle handle)</span> </span>&#123; <span class="comment">//将handle作为参数传递，根据handle的不同实现，筛选出不同的苹果。</span></span><br><span class="line">        <span class="keyword">for</span> (Apple apple : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handle.test(apple)) &#123;</span><br><span class="line">                System.out.println(apple);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>方法1 实现接口，在以往当中都是继承接口，实现类，这是Java当中非常普遍的思路，如同线程的Runnable 接口，或者Comparator 接口，在排序list时，通常使用Collections.sort() 或者 list.sort() 方法进行排序，这两个方式都需要实现一个Comparator 接口，比较器比较列表每一项的大小，根据比较器的返回值得到不同的排序结果。</p>
<p>这也是在Java 8 之前的普遍行径，然而 不同的行为都需要 继承 同一个接口，实现不同的类，再传递给方法的过程太繁琐，为了简便，便进一步简化操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Apple&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">108</span>,<span class="string">"beijing"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">120</span>,<span class="string">"shanghai"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"green"</span>,<span class="number">123</span>,<span class="string">"beijing"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"black"</span>,<span class="number">201</span>,<span class="string">"shanxi"</span>));</span><br><span class="line"></span><br><span class="line">        AppleTest.filter(list, <span class="keyword">new</span> Applehandle());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Applehandle</span> <span class="keyword">implements</span> <span class="title">handle</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> apple.getWeight()&gt;<span class="number">120</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法2 匿名内部类 这也是Java 以往用到的行径，与实现不同的类相比，这个更加地简便 ，但也同样繁琐。</p>
<p>前面的是筛选出重量大于120的苹果，而现在的是选出颜色为红色的苹果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppleTest.filter(list, <span class="keyword">new</span> handle() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> apple.getColor().equals(<span class="string">"red"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>



<p>方法3 lambda表达式 ，这是Java 8 新引入的概念，也是函数式编程的思想体现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppleTest.filter(list, (Apple apple)-&gt;apple.getProduceArea().equals(<span class="string">"shanghai"</span>));</span><br></pre></td></tr></table></figure>



<p>这里能用到lambda表达式，是filter 方法的第二个参数handle是 只有一个抽象方法的接口，如果接口的抽象方法大于一个，那么，就无法使用lambda表达式。</p>
<p>方法的引用无疑就是为了重复使用同一个行为，在这个类能使用，别的类也能使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Choose</span> <span class="keyword">implements</span> <span class="title">handle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Apple apple)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apple.getWeight()&gt;<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   Choose choose=<span class="keyword">new</span> Choose();</span><br><span class="line">   AppleTest.filter(list,choose::test); <span class="comment">//引用choose对象中的test方法</span></span><br></pre></td></tr></table></figure>



<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><p>类型根据上下文判断 </p>
<p>lambda表达式可以访问外围方法或类的变量值，但不能修改它们的值，因为lambda默认变量的修饰符为final 。</p>
<p><strong>环绕模式</strong></p>
<p>如文件的普遍操作</p>
<p>流的初始化   对流进行不同的操作  流的释放</p>
<p>在不同的业务场景中，第一步和最后一步的操作是大体相同，无差异的，这个时候就可以对中间部分进行参数行为化处理，将整个流程封装成一个具体的方法，而该方法的参数为中间操作的行为，及行为参数化。</p>
<p>除了文件的读写操作，还行JDBC的操作等等。</p>
<p>函数描述符    ( )-&gt;return  参数类型+返回值类型 ，声明泛型时，依照参数类型在先，返回类型再后的顺序声明。consumer&lt;Long,String,HashMap&gt;</p>
<p>常用的函数式接口</p>
<p>Consumer<T> void accept(T t)<br>Suppller<T>   T get()<br>Function&lt;T,R&gt;  R apply(T t)<br>Predicate<T>  boolean test(T t)</p>
<p>目标类型，lambda都能匹配到不同的目标类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparetor&lt;Apple&gt; c1=(Apple a1,Apple a2)-&gt;a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">Comparetor&lt;Apple,Apple&gt; c2=(Apple a1,Apple a2)-&gt;a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">Comparetor&lt;Apple,Apple,Integer&gt; c3=(Apple a1,Apple a2)-&gt;a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure>



<p>避免装箱   </p>
<p>对于专门输入参数的引用类型和输出类型，四大函数接口都有专门的原始类型前缀，用来避免自动装箱机制</p>
<p>如IntPredicate LongPredicate ToIntFunction</p>
<p>实例变量 静态变量 局部变量</p>
<p>由于实例变量和静态变量在堆中，是所有的线程共有的，在lambda内部访问他们，甚至修改他们都不会造成线程安全问题，而局部变量是存在栈里面的，是线程私有的，访问局部变量可能会造成读写冲突等问题，是线程不安全的。</p>
<p>处理异常</p>
<p>lambda表达式不能抛出检查异常Checked Exception，所以它只能在函数接口声明时，声明抛出检查异常 ；或者在lambda在内部用try ,catche语法块处理异常。</p>
<p>方法引用就是lambda的语法糖</p>
<p><strong>构造函数的引用</strong></p>
<p>对一个现有构造函数，可以利用它的名称和关键字new 来创建它的一个引用。</p>
<p>ClassName::new </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c=Apple::<span class="keyword">new</span> ;</span><br><span class="line"> c.get() ; </span><br><span class="line"> <span class="comment">// Apple 的默认构造函数 的描述符是 ()-&gt;Apple ;而Supplier的目标类型刚好与子匹配</span></span><br><span class="line"> <span class="comment">//调用supplier的方法，将会执行构造函数，创建一个Apple的实例对象。</span></span><br></pre></td></tr></table></figure>





<p><strong>复杂的表达</strong></p>
<p>比较器链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator.comparing(Item::getNum).reversed();</span><br><span class="line"><span class="comment">//先是比较Item::getNum，如果比较结果为相等，再比较Item::getDes</span></span><br><span class="line">Comparator.comparing(Item::getNum).thenComparing(Item::getDes);</span><br></pre></td></tr></table></figure>



<p>谓词复合</p>
<p>谓词接口包括了三个方法  and ，or ，negate非</p>
<p>优先级从左至右</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;Item&gt; not=item -&gt; item.getNum()==<span class="number">100</span>;</span><br><span class="line">Predicate&lt;Item&gt; not1=not.negate();<span class="comment">//item.getNum != 100</span></span><br><span class="line">Predicate&lt;Item&gt; or=not.or(item -&gt; item.getNum()&gt;<span class="number">120</span>);<span class="comment">// item.getNum==100 or item.getNum &gt;120</span></span><br><span class="line">Predicate&lt;Item&gt; and=not.and(item -&gt; item.getDes().equals(<span class="string">"ff"</span>)); <span class="comment">//item.getNum==100 and item.getDec == ff</span></span><br></pre></td></tr></table></figure>

<p> 函数复合</p>
<p>Function接口所代表的andThen compose</p>
<p>它们会返回一个Function函数实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer,Integer&gt; f=x-&gt;x+<span class="number">1</span>;</span><br><span class="line">Function&lt;Integer,Integer&gt; g=x-&gt;x*<span class="number">2</span>;</span><br><span class="line">Function&lt;Integer,Integer&gt; h=f.andThen(g);</span><br><span class="line">System.out.println(h.apply(<span class="number">6</span>));<span class="comment">//14  相当于g( f(x) )</span></span><br><span class="line"></span><br><span class="line">Function&lt;Integer,Integer&gt; h=f.compose(g);  <span class="comment">//相当于 f( g(x) )</span></span><br><span class="line">System.out.println(h.apply(<span class="number">6</span>));<span class="comment">//13</span></span><br></pre></td></tr></table></figure>







<h4 id="流-Stream"><a href="#流-Stream" class="headerlink" title="流 Stream"></a>流 Stream</h4><p>流 支持数据处理操作的 源 生成的 元素序列 。</p>
<p>流的两个特点 流水线 内部迭代</p>
<p>流 中间操作链 终端操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; list= <span class="keyword">new</span> ArrayList&lt;Apple&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">100</span>,<span class="string">"shanghai"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"red"</span>,<span class="number">120</span>,<span class="string">"tianjing"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"yellow"</span>,<span class="number">134</span>,<span class="string">"beijing"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"yellow"</span>,<span class="number">321</span>,<span class="string">"nanning"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"black"</span>,<span class="number">230</span>,<span class="string">"nanning"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Apple(<span class="string">"grey"</span>,<span class="number">145</span>,<span class="string">"beijing"</span>));</span><br><span class="line"></span><br><span class="line">stream.filter((apple -&gt; apple.getWeight()&gt;<span class="number">130</span>)).forEach(System.out::println);</span><br><span class="line">Apple&#123;color=<span class="string">'yellow'</span>, weight=<span class="number">134</span>, address=<span class="string">'beijing'</span>&#125;</span><br><span class="line">Apple&#123;color=<span class="string">'yellow'</span>, weight=<span class="number">321</span>, address=<span class="string">'nanning'</span>&#125;</span><br><span class="line">Apple&#123;color=<span class="string">'black'</span>, weight=<span class="number">230</span>, address=<span class="string">'nanning'</span>&#125;</span><br><span class="line">Apple&#123;color=<span class="string">'grey'</span>, weight=<span class="number">145</span>, address=<span class="string">'beijing'</span>&#125;</span><br><span class="line"></span><br><span class="line"> stream.filter((apple -&gt; apple.getWeight()&gt;<span class="number">130</span>)).map(Apple::getWeight).sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">/**134</span></span><br><span class="line"><span class="comment">145</span></span><br><span class="line"><span class="comment">230</span></span><br><span class="line"><span class="comment">321</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">stream.filter((apple -&gt; apple.getWeight()&gt;<span class="number">130</span>)).map(Apple::getAddress).limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">beijing</span><br><span class="line">nanning</span><br><span class="line"></span><br><span class="line">stream.filter((apple -&gt; apple.getWeight()&gt;<span class="number">130</span>)).map(Apple::getAddress).skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">nanning</span><br><span class="line">beijing</span><br><span class="line"></span><br><span class="line">Long i= stream.filter((apple -&gt; apple.getWeight()&gt;<span class="number">130</span>)).map(Apple::getAddress).count();</span><br><span class="line">        System.out.println(i); <span class="comment">// i=4</span></span><br></pre></td></tr></table></figure>



<p>limit skip是互补的。</p>
<p>filter筛选</p>
<p>dinstinct 排除相同的元素     collect(Collectors.toSet())也可以做到类似的效果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list1= Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>);</span><br><span class="line">    list1.stream().distinct().forEach(System.out::print);</span><br><span class="line">    <span class="comment">//123486</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; integers=  list1.stream().collect(Collectors.toSet());</span><br><span class="line">       System.out.println(integers);</span><br><span class="line">       <span class="comment">//[1, 2, 3, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<p>map映射</p>
<p>流的扁平化</p>
<p>flatMap   将各个流合扁平化为一个单个流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings=Arrays.asList(<span class="string">"java8"</span>,<span class="string">"lambda"</span>,<span class="string">"stream"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String[]&gt; S=strings.stream().map(word-&gt;word.split(<span class="string">""</span>)).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>map返回的流类型是 Stream&lt;String[]&gt; ，是因为split函数返回的类型是String[] , 而我们想要的流是Stream<String> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] streams=&#123;<span class="string">"good"</span>,<span class="string">"hello"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stringStream=Arrays.stream(streams);</span><br><span class="line"></span><br><span class="line">List&lt;Stream&gt; S=strings.stream().map(word-&gt;word.split(<span class="string">""</span>)).map(Arrays::stream).distinct().collect(Collectors.toList());</span><br><span class="line"><span class="comment">//得到的是一个流的列表</span></span><br><span class="line">S.get(<span class="number">0</span>).forEach(System.out::print);<span class="comment">//Java 8</span></span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strings=Arrays.asList(<span class="string">"java8"</span>,<span class="string">"lambda"</span>,<span class="string">"stream"</span>);</span><br><span class="line">        List&lt;String&gt; s=strings.stream().map(word-&gt;word.split(<span class="string">""</span>)).flatMap(Arrays::stream).distinct().collect(Collectors.toList());</span><br><span class="line">        System.out.println(s);</span><br><span class="line"><span class="comment">//[j, a, v, 8, l, m, b, d, s, t, r, e]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计苹果省份的单词</span></span><br><span class="line">System.out.println(list.stream().map(Apple::getAddress).map(s1 -&gt; s1.split(<span class="string">""</span>)).flatMap(Arrays::stream).distinct().collect(Collectors.toList()));</span><br><span class="line"><span class="comment">//[s, h, a, n, g, i, t, j, b, e]</span></span><br></pre></td></tr></table></figure>



<p>匹配</p>
<p>anyMatch allMatch noneMatch 都是终端操作，返回一个布尔值，anyMatch匹配到任意的一个返回真，allMatch和 noneMatch是相对的，前者是匹配到所以，后者是没有一个能匹配，这三个操作都是短路操作。可以用来短路求值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(stream.anyMatch(apple -&gt; apple.getColor().equals(<span class="string">"red"</span>)));</span><br><span class="line"><span class="comment">//true </span></span><br><span class="line"></span><br><span class="line">System.out.println(stream.allMatch(apple -&gt; apple.getColor().equals(<span class="string">"red"</span>)));</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"> System.out.println(stream.noneMatch(apple -&gt; apple.getColor().equals(<span class="string">"red"</span>)));</span><br><span class="line"><span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<p>查找</p>
<p>findAny 返回流中的任意一个元素</p>
<p>findFirst 返回流中的第一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Apple&gt;optional=stream.findAny();</span><br><span class="line">System.out.println(optional.get().toString());</span><br><span class="line"></span><br><span class="line">Optional&lt;Apple&gt;optional=stream.filter(apple -&gt; apple.getWeight()&gt;<span class="number">200</span>).findFirst();</span><br><span class="line">       System.out.println(optional.get().toString());</span><br></pre></td></tr></table></figure>



<p>归约</p>
<p>reduce 有两个重载，方法有两个参数的返回一个具体的类型对，如果没有初始值，返回的是一个Optional<T>,因为要考虑到流中没有任何元素。</p>
<p>元素求和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers=Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> i=  numbers.stream().reduce(<span class="number">0</span>,(a,b)-&gt;a+b);</span><br><span class="line"><span class="comment">//int i=  numbers.stream().reduce(0,Integer::sum);</span></span><br><span class="line">        System.out.println(i);<span class="comment">//36</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Integer&gt;c=  numbers.stream().reduce(Integer::sum);</span><br><span class="line">        System.out.println(c.get());<span class="comment">//36</span></span><br><span class="line">Optional&lt;Integer&gt;c=  numbers.stream().reduce(Integer::max);</span><br><span class="line">        System.out.println(c.get());<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; numbers=Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">int</span> i=  numbers.stream().reduce(<span class="number">1</span>,(a,b)-&gt;a*b);</span><br><span class="line">        System.out.println(i);<span class="comment">//40320</span></span><br></pre></td></tr></table></figure>



<p>流操作 有状态 和 无状态</p>
<p>事关并行流操作，在有状态的操作下，流的操作需要知道前面的操作，不然无法进行并行操作。</p>
<p>比如map是无状态的，会从输入流中获取每一个元素，并在输出流得到具体的结果，而sorted是排序操作，是需接受一个具体的流再生成一个新的流，操作对象是流，不是流中的元素。</p>
<p>filter map flatMap 是无状态的</p>
<p>distinct skip limit sorted 是有状态的</p>
<p>reduce是有状态有界的，终端操作。</p>
<p><strong>数值流</strong></p>
<p>IntStream LongStream DoubleStream</p>
<p>有这些流的存在是避免装箱机制</p>
<p>boxed将数值流转换成Stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStream= list.stream().mapToInt(Apple::getWeight);</span><br><span class="line"></span><br><span class="line">System.out.println(list.stream().mapToInt(Apple::getWeight).max());</span><br><span class="line"><span class="comment">//OptionalInt[321]</span></span><br><span class="line"> System.out.println(list.stream().mapToInt(Apple::getWeight).average());</span><br><span class="line"><span class="comment">//OptionalDouble[175.0]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (list.stream().mapToInt(Apple::getWeight) <span class="keyword">instanceof</span> IntStream)&#123;</span><br><span class="line">            System.out.println(<span class="string">"intstream"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"stream"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>



<p>数值流的rangeClosed range</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream intStream=IntStream.rangeClosed(<span class="number">1</span>,<span class="number">100</span>).filter(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line">        System.out.println(intStream.count());<span class="comment">//50 ，因为1-100</span></span><br><span class="line"></span><br><span class="line">IntStream intStream=IntStream.range(<span class="number">1</span>,<span class="number">100</span>).filter(n-&gt;n%<span class="number">2</span>==<span class="number">0</span>);</span><br><span class="line">        System.out.println(intStream.count());<span class="comment">//49 ，1-99</span></span><br></pre></td></tr></table></figure>



<p><strong>构建流</strong></p>
<p>有值生成流  Stream<String> s=Stream.of(“java”,”lambda”,”hai”);</p>
<p>有数组生成流 Arrays.stream()</p>
<p>有文件生成流 </p>
<p><strong>无限流</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stream.iterate(0,n-&gt;n+2).limit(4).forEach(System.out::print);</span><br><span class="line">&#x2F;&#x2F;0246</span><br><span class="line"></span><br><span class="line"> Stream.generate(Math::random).limit(5).forEach(System.out::print);</span><br></pre></td></tr></table></figure>



<h4 id="Collectors方法"><a href="#Collectors方法" class="headerlink" title="Collectors方法"></a><strong>Collectors方法</strong></h4><p>收集器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> i= list.stream().collect(Collectors.counting());</span><br><span class="line">System.out.println(i); <span class="comment">//返回流中的元素个数 stream().count()效果相同。</span></span><br><span class="line"></span><br><span class="line">Comparator&lt;Apple&gt; appleComparator=Comparator.comparingInt(Apple::getWeight);</span><br><span class="line">Optional&lt;Apple&gt;  O= list.stream().collect(Collectors.maxBy(appleComparator));</span><br><span class="line">System.out.println(O.get()); <span class="comment">//选出流中苹果重量最大的苹果</span></span><br><span class="line"><span class="comment">//Optional&lt;Apple&gt;  O= list.stream().collect(Collectors.minBy(appleComparator));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> average=list.stream().collect(Collectors.averagingDouble(Apple::getWeight));</span><br><span class="line">        System.out.println(average);<span class="comment">//苹果的平均体重。</span></span><br><span class="line"></span><br><span class="line">DoubleSummaryStatistics summary=list.stream().collect(Collectors.summarizingDouble(Apple::getWeight));</span><br><span class="line">        System.out.println(summary.toString());</span><br><span class="line"><span class="comment">//DoubleSummaryStatistics&#123;count=6, sum=1050.000000, min=100.000000, average=175.000000, max=321.000000&#125; 得到苹果关于重量的相关信息</span></span><br><span class="line"></span><br><span class="line">String s1=list.stream().map(Apple::getAddress).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"><span class="comment">//shanghai,tianjing,beijing,nanning,nanning,beijing 将字符串连接，用，逗号分隔，joining另一个重载方法可以没有参数。</span></span><br></pre></td></tr></table></figure>



<p><strong>更广义的归约汇总</strong></p>
<p>reducing 方法有三个参数的，第一个参数是初始值，第二参数是Function 函数，可以叫映射mapper方法，最后一个参数是 BinaryOperator</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i=list.stream().collect(Collectors.reducing(<span class="number">0</span>,Apple::getWeight,(k,j)-&gt;k+j));</span><br><span class="line">System.out.println(i);<span class="comment">//1050</span></span><br><span class="line"></span><br><span class="line">Optional&lt;Apple&gt; optional=list.stream().collect(Collectors.reducing((d1,d2)-&gt;d1.getWeight()&gt;d2.getWeight()?d1:d2));</span><br><span class="line">        System.out.println(optional.get());</span><br><span class="line"><span class="comment">//Apple&#123;color='yellow', weight=321, address='nanning'&#125; 选出重量最重的苹果</span></span><br><span class="line"></span><br><span class="line">String string=list.stream().collect(Collectors.reducing(<span class="string">""</span>,Apple::getAddress,(s1,s2)-&gt;s1+<span class="string">","</span>+s2));</span><br><span class="line">System.out.println(string);</span><br><span class="line"><span class="comment">//同上的joining</span></span><br></pre></td></tr></table></figure>



<p><strong>分组</strong></p>
<p>groupingBy 方法有一个参数的方法，传入的是方法的键key。此方法的第二个参数是默认的toList()</p>
<p>第二个参数代表map的值类型，可以是list ,可以是另一个groupingBy，进行多层分组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,List&lt;Apple&gt;&gt; map=list.stream().collect(Collectors.groupingBy(Apple::getColor));</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">//安装苹果的颜色分组</span></span><br><span class="line"></span><br><span class="line"> Map&lt;String, Map&lt;String, List&lt;Apple&gt;&gt;&gt; map=list.stream().collect(Collectors.groupingBy(Apple::getColor,Collectors.groupingBy(Apple::getAddress)));</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//多层分组，先按照苹果的颜色分组，再按照苹果的产地分组</span></span><br><span class="line">        </span><br><span class="line">Map&lt;String, Map&lt;String, Long&gt;&gt; map=list.stream().collect(Collectors.groupingBy(Apple::getColor,Collectors.groupingBy(Apple::getAddress,Collectors.counting())));<span class="comment">// 第二层分组的值是Long,因为counting的结果是Long类型</span></span><br><span class="line">        System.out.println(map);</span><br></pre></td></tr></table></figure>



<p><strong>分区</strong></p>
<p>与分组不同，分区只有两个组，一个是true ，一个是false</p>
<p>它的用法和分组类似，第一个参数是Predicate 返回的是布尔类型 ，第二个参数是map的value，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Boolean,Long&gt; map=list.stream().collect(Collectors.partitioningBy(Apple::getLike,Collectors.counting()));</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">//&#123;false=4, true=2&#125;</span></span><br><span class="line"></span><br><span class="line">Map&lt;Boolean,List&lt;Apple&gt;&gt; map=list.stream().collect(Collectors.partitioningBy(Apple::getLike));</span><br><span class="line">        System.out.println(map);</span><br></pre></td></tr></table></figure>



<h4 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream stream= list.stream().parallel();  <span class="comment">//parallel将顺序流转换成并行流</span></span><br><span class="line">Stream stream= list.stream().parallel().sequential();<span class="comment">//sequential将并行流转换顺序流</span></span><br></pre></td></tr></table></figure>



<p><strong>测量</strong>，把顺序流转换成并行流轻而易举，但却不一定是好事，要想知道效率，还需要测量并行流和顺序流的执行时间。</p>
<p>留意装箱，自动装箱和拆箱会大大降低效率，Java8中有原始类型流IntStream等，但凡能用上，最后用到。</p>
<p>流有些操作在顺序流中比在并行流中更具有效率，比如limit findFirst ，这些操作在并行流中的执行代价非常大。</p>
<p>考虑流操作流水线的总计算成本，N为要处理的元素总数，而Q代表一个元素通过流水线的大致处理成本，Q越大，使用并行流的性能更好。</p>
<p>对于较小的数据量，顺序流更好。</p>
<p><strong>考虑流背后的数据结构是否易于分解</strong>，列如ArrayList的拆分效率比LinkedList要好。</p>
<p>流自身的特点，中间操作可能改变流的方式。</p>
<p><strong>最后要考虑终端操作中合并步骤的代价是大，还是小，如果这部代价很大，那么组合子流产生的付出结果可能比并行流的性能更大，这时并行流不是一个好选择。</strong></p>
<p><strong>peek</strong></p>
<p>stream 流方法中 peek() 可以用来检测stream每步操作执行前，或执行后流元素的状态，只有在peek方法传入相应的表达式，并且peek方法并不会forEach 那样终结流的操作。</p>
<p>lambda表达式应用到环绕模式外，还可以用到另外一个场景。</p>
<p>如果在代码中普遍检查一个对象的级别，类似日志的级别，然后执行相应的代码，这里可以也可以用到lambda表达式，当然lambda表达式的用途还有很多。</p>
<p>用于改进设计模式</p>
<p>如策略模式，模板方法，工厂模式，责任链模式，都可以用到lambda表达式进行改进。</p>
<h4 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h4><p>接口的默认方法和静态方法</p>
<p>default static</p>
<p>接口内的默认方法和静态方法都能提供实现</p>
<p>接口可以直接调用静态方法，而不能使用默认方法，只有它的继承者如果没有覆盖默认方法下，继任者可以直接调用默认方法。</p>
<p>默认方法的用途，<strong>接口演化</strong>，如果一个接口有很多的继承类，为接口添加一个新的方法，你就要更新所有的继承类，如果不这样做，就会导致编译错误，为了减少繁琐的操作，为新的方法设置成默认方法，并添加一个默认的实现，如果继承类用不到也就无需更改默认方法。</p>
<p><strong>解决默认方法的冲突：</strong></p>
<ol>
<li>超类优先。</li>
<li>接口冲突，具体看继承的接口的关系，如果编译器无法判断使用那个接口的默认方法，就需要显示地覆盖默认方法。</li>
</ol>
<p><strong>函数式编程思想</strong></p>
<p>我们希望函数传入的对象是不可变的，或者我们不应该改变传入对象的值，如果需要进行修改，那么应该创建一个副本，对副本进行操作，返回副本。</p>
<p>无论在何时，传入相同的参数都应该返回相同的结果。</p>
<p>函数体应该装在匣子里，不暴露给用户，而且应该没有副作用，不应该修改函数外面字段的值。</p>
<p>使用递归，避免使用迭代，因为迭代意味着循环中有变量会更新，但递归效率低下。但Java流的特性可以解决部分递归带来的效率低下的问题，函数式语言提供了一种方法解决，那就是<strong>尾调优化</strong>，在return 处进行迭代，即调用自身。但Java目前不支持，所以只能使用Stream替换迭代操作。</p>
<h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p>Optional可以简单理解为一个对象包装器。如果这个对象包装器不允许为空，如果对象包装器没有对象，那么获取对象时就会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String des;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三个静态方法创建Optional对象</span></span><br><span class="line">Optional&lt;Item&gt; optionalItem=Optional.empty();</span><br><span class="line">Optional&lt;Item&gt; optionalItem1=Optional.of(<span class="keyword">new</span> Item(<span class="string">"df"</span>,<span class="number">3</span>));</span><br><span class="line">Optional&lt;Item&gt; optionalItem2=Optional.ofNullable(<span class="keyword">null</span>);<span class="comment">//允许为空</span></span><br><span class="line"></span><br><span class="line">optionalItem.get(); <span class="comment">//抛出异常，一般而言不会用get方法获取对象</span></span><br><span class="line">optionalItem2.orElse(<span class="keyword">new</span> Item(<span class="string">"1"</span>,<span class="number">3</span>));<span class="comment">//一般使用该方法获取对象，因为如果对象不存在你可以使用新创建的对象，解决空异常</span></span><br><span class="line">optionalItem2.ifPresent(s-&gt; System.out.println(s));<span class="comment">//如果不为空，就进行该操作</span></span><br></pre></td></tr></table></figure>

<p>Optional是不能被序列化的，所以一般而言在类属性中不可能存在被Opntional包裹的属性，但是可以使用get()方法，返回的是经过包装的属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Optional&lt;String&gt; getDes() &#123;</span><br><span class="line">    return Optional.of(this.des);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Optional的三个方法</p>
<p>filter  根据包装器内对象进行的判断，返回布尔值，如果布尔值为真，那么包装器返回原来的对象，如果为假，包装器为空</p>
<p>map 映射操作  比如 <code>Optional&lt;String&gt;- &gt;Optional&lt;Integer&gt;</code></p>
<p>flatMap 也是映射操作，但它接受的对象是被Optional多重包装，如果对一个类似的被Optional包装器多次包装的进行映射，需要用flatMap方法。<code>Optional&lt;Optional&lt;String&gt;&gt;</code></p>
<h4 id="新的日期函数"><a href="#新的日期函数" class="headerlink" title="新的日期函数"></a>新的日期函数</h4><p>LocalDate LocalTime Instant Duration Period</p>
<p>LocalDateTime</p>
<p>TemporalAdjuster</p>
<h4 id="高阶函数-科里化"><a href="#高阶函数-科里化" class="headerlink" title="高阶函数 科里化"></a>高阶函数 科里化</h4><h2 id="Java9新特性"><a href="#Java9新特性" class="headerlink" title="Java9新特性"></a>Java9新特性</h2><p><strong>模块系统</strong></p>
<p>module 是一些包的容器。</p>
<p>依赖它的应用称之为模块，模块是有名字的，其他模块使用该名字使用它。</p>
<p>module导出特定的包，仅供依赖它的包使用。</p>
<p>module-info.java是用在保存module信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> com.foo.bar&#123;</span><br><span class="line">  <span class="keyword">exports</span> com.foo.bar.alpha;<span class="comment">//包</span></span><br><span class="line">  <span class="keyword">exports</span> com.foo.bar.beta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> com.foo.app&#123;</span><br><span class="line">  <span class="keyword">requires</span> com.foo.bar;<span class="comment">//引用其他的模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p><strong>REPL(JShell) 交换式编程环境</strong></p>
<p>相当于cmd工具，输入jshell</p>
<p><strong>HTTP2客户端</strong></p>
<p>引进HttpClient</p>
<p><strong>改进的Javadoc</strong></p>
<p>命令行增加-html5参数 生产的文档支持HTML5标准</p>
<p><strong>多版本兼容jar包</strong></p>
<p>多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。</p>
<p><strong>通过–release 参数指定编译版本</strong></p>
<p>具体的变化就是 META-INF 目录下 MANIFEST.MF 文件新增了一个属性：</p>
<p>Multi-Release: true</p>
<p><strong>集合工厂方法</strong></p>
<p>可以用新的集合静态方法创建不可变的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static &lt;E&gt; List&lt;E&gt; of(E e1, E e2, E e3); &#x2F;&#x2F;参数不能操作10个</span><br><span class="line">static &lt;E&gt; Set&lt;E&gt;  of(E e1, E e2, E e3);</span><br><span class="line">static &lt;K,V&gt; Map&lt;K,V&gt; of(K k1, V v1, K k2, V v2, K k3, V v3);</span><br><span class="line">static &lt;K,V&gt; Map&lt;K,V&gt; ofEntries(Map.Entry&lt;? extends K,? extends V&gt;... entries)&#x2F;&#x2F;超过10个参数用次方法</span><br></pre></td></tr></table></figure>



<p>Java8以前的方法是：</p>
<p>set = Collections.unmodifiableSet(set);</p>
<p> list = Collections.unmodifiableList(list); </p>
<p>map = Collections.unmodifiableMap(map); </p>
<p><strong>私有接口方法</strong></p>
<p>接口的方法允许用private修饰符修饰方法</p>
<p><strong>进程API</strong></p>
<p>Java 9 向 Process API 添加了一个名为 ProcessHandle 的接口来增强 java.lang.Process 类。</p>
<p>ProcessHandle 接口的实例标识一个本地进程，它允许查询进程状态并管理进程。</p>
<p>ProcessHandle 嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。</p>
<p><strong>string底层存储结构更换</strong></p>
<p>  java8之前 String的底层结构类型都是 char[] ,但是java9 就替换成 byte[] 这样来讲，更节省了空间和提高了性能。java9 是基于ISO/latin1/Utf-16。</p>
<p>UTF-16无论什么文字，都恒定用两个字节表示一个字符。</p>
<p><strong>改进的Stream API</strong></p>
<p>takeWhile 返回给定 Stream 的子集直到断言语句第一次返回 false。如果第一个值不满足断言条件，将返回一个空的 Stream。</p>
<p>dropWhile  与上面的相反</p>
<p>ofNullable ，ofNullable 方法可以预防 NullPointerExceptions 异常， 可以通过检查流来避免 null 值。</p>
<p> iterate 不加条件无限循环</p>
<p><strong>改进try-with-resources</strong></p>
<p>每一个流打开的时候都要关闭,但是在try的括号中来进行关闭，在java8的基础上进一步升级 直接在try括号中直接写入 变量就好，如果有多个流，就用分号隔开</p>
<p>Java9：</p>
<p><strong>在try里面直接调用已经实例化的资源对象</strong></p>
<p>try(reader;writer){}</p>
<p>改进的启用注解@Deprecated</p>
<p><strong>改进钻石操作符</strong></p>
<p>Java6： Map&lt;String,String&gt; map7 = new HashMap&lt;String,String&gt;();</p>
<p>Java7，8：Map&lt;String,String&gt; map8 = new HashMap&lt;&gt;();</p>
<p>java9 添加了匿名内部类的功能 后面添加了大括号{}  可以做一些细节的操作</p>
<p>Java9： Map&lt;String,String&gt; map9 = new HashMap&lt;&gt;(){};</p>
<p><strong>多分辨率图像</strong></p>
<ul>
<li><strong>Image getResolutionVariant(double destImageWidth, double destImageHeight)</strong> − 获取特定分辨率的图像变体-表示一张已知分辨率单位为DPI的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。。</li>
<li><strong>List getResolutionVariants()</strong> − 返回可读的分辨率的图像变体列表。</li>
</ul>
<p><strong>改进的CompletableFuture API</strong></p>
<p>支持delays 和timeout</p>
<p>提升对子类化的支持</p>
<p>新的工厂方法</p>
<p><strong>轻量级的JSON API</strong></p>
<p>在java.util 内发布</p>
<p><strong>响应式流(Reactive Streams)API</strong></p>
<p>Reactive Stream (响应式流/反应流) 是JDK9引入的一套标准，是一套基于发布/订阅模式的数据处理规范。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Subscription 接口定义了连接发布者和订阅者的方法</span><br><span class="line">Publisher<span class="tag">&lt;<span class="name">T</span>&gt;</span> 接口定义了发布者的方法</span><br><span class="line">Subscriber<span class="tag">&lt;<span class="name">T</span>&gt;</span> 接口定义了订阅者的方法</span><br><span class="line">Processor<span class="tag">&lt;<span class="name">T,R</span>&gt;</span> 接口定义了处理器</span><br></pre></td></tr></table></figure>



<p><strong>Java9钱和货币的API</strong></p>
<p>新的类型Money, FastMoney</p>
<p><strong>特殊标识符增加限制</strong></p>
<p>下划线不能作为变量</p>
<p><strong>改进Optional类</strong></p>
<p>stream()</p>
<p>ifPresentOrElse()</p>
<p>or()</p>
<p>垃圾回收器默认采用了G1</p>
<p>JIT编译器的新特性 代码分段缓存</p>
<p>只能Java编译</p>
<h2 id="java10新特性"><a href="#java10新特性" class="headerlink" title="java10新特性"></a>java10新特性</h2><p><strong>完全支持Linux容器，包括docker</strong></p>
<p>JVM现在可以识别由容器控制组(cgroups) 设置的约束。可以在容器中使用内存和CPU约束来直接管理Java应用程序。</p>
<p><strong>局部变量的类型推断 var关键字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      list.add(<span class="string">"hello，world！"</span>);</span><br><span class="line">      System.out.println(list);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>GC改进和内存管理 引入并行全垃圾回收期G1</p>
<p>垃圾回收器接口</p>
<p>线程-局部变量管控</p>
<p>线程局部管控。允许停止单个线程，而不是只能启用或停止所有线程</p>
<p>合并JDK多大代码仓库到一个单独的存储库</p>
<p>新的API</p>
<p>ByteArrayOutputStream</p>
<p>List Map Set</p>
<p>Properties</p>
<p>Collectors收集器</p>
<p>额外的 Unicode 语言标签扩展</p>
<p><strong>基于时间的版本控制</strong></p>
<p>移除 JDK 中附带的 javah 工具。可以使用 javac -h 代替</p>
<p>应用类数据共享。为改善启动和占用空间，在现有的类数据共享（“CDS”）功能上再次拓展，以允许应用类放置在共享存档中</p>
<h2 id="Java11新特性"><a href="#Java11新特性" class="headerlink" title="Java11新特性"></a>Java11新特性</h2><p><strong>字符串增强 新的API</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line"><span class="string">" "</span>.isBlank(); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 去除首尾空格</span></span><br><span class="line"><span class="string">" Hello Java11 "</span>.strip(); <span class="comment">// "Hello Java11"</span></span><br><span class="line"><span class="comment">// 去除尾部空格 </span></span><br><span class="line"><span class="string">" Hello Java11 "</span>.stripTrailing(); <span class="comment">// " Hello Java11"</span></span><br><span class="line"><span class="comment">// 去除首部空格 </span></span><br><span class="line"><span class="string">" Hello Java11 "</span>.stripLeading(); <span class="comment">// "Hello Java11 "</span></span><br><span class="line"><span class="comment">// 复制字符串</span></span><br><span class="line"><span class="string">"Java11"</span>.repeat(<span class="number">3</span>); <span class="comment">// "Java11Java11Java11"</span></span><br><span class="line"><span class="comment">// 行数统计</span></span><br><span class="line"><span class="string">"A\nB\nC"</span>.lines().count(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>



<p><strong>集合新的静态方法</strong> 10</p>
<p>copyOf 创建不可变的集合，参数是集合</p>
<p><strong>直接运行Java文件，不用编译</strong></p>
<p>java java11.java</p>
<p><strong>Flight Recorder</strong></p>
<p>Java11开源的项目</p>
<p>可以启动程序后用 <strong>jcmd 命令</strong>录制</p>
<p>Java 语言中的飞行记录器类似飞机上的黑盒子，是一种低开销的事件信息收集框架，主要用于对应用程序和 JVM 进行故障检查、分析。飞行记录器记录的主要数据源于应用程序、JVM 和 OS，这些事件信息保存在单独的事件记录文件中，故障发生后，能够从事件记录文件中提取出有用信息对故障进行分析。</p>
<p><strong>用于lambda参数的局部变量</strong></p>
<p>Java 11 与 Java 10 的不同之处在于允许开发者在 Lambda 表达式中使用 var 进行参数声明。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Nonnull var x &#x3D; new Foo();</span><br><span class="line">(@Nonnull var x, @Nullable var y) -&gt; x.process(y)</span><br></pre></td></tr></table></figure>



<p>支持TLS1.3协议</p>
<p>新的垃圾收集器，实验性质</p>
<p>Epsilon ； ZGC</p>
<p>Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息。</p>
<h2 id="Java12新特性"><a href="#Java12新特性" class="headerlink" title="Java12新特性"></a>Java12新特性</h2><p><strong>改进switch</strong></p>
<p>相比之前，用-&gt;代替了：，变量还能接收的返回值switch</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> numberOfLetters= <span class="keyword">switch</span>(fruit)&#123;</span><br><span class="line"><span class="keyword">case</span> PEAR-&gt;<span class="number">4</span>;</span><br><span class="line"><span class="keyword">case</span> APPLE,MANGO-&gt;<span class="number">5</span>;</span><br><span class="line"><span class="keyword">case</span> ORAGE-&gt;<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Shenandoah的GC算法</p>
<h2 id="Java13新特性"><a href="#Java13新特性" class="headerlink" title="Java13新特性"></a>Java13新特性</h2><p><strong>文本块升级</strong></p>
<p>重新实现旧版本的套字</p>
<p>Unicode12.1</p>
<h2 id="java14新特性"><a href="#java14新特性" class="headerlink" title="java14新特性"></a>java14新特性</h2><p><strong>instanceof</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="string">"程序新视界"</span>;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">	String str = (String) obj;</span><br><span class="line">	System.out.println(<span class="string">"关注公众号："</span> + str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化预览版本</span></span><br><span class="line"></span><br><span class="line">Object obj = <span class="string">"程序新视界"</span>;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> String str)&#123;</span><br><span class="line">	System.out.println(<span class="string">"关注公众号："</span> + str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>新增打包工具jpackage</strong></p>
<p>可以用于构建exe,pkg等格式的安装文件</p>
<p><strong>switch标准化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">case</span> TUESDAY                -&gt; System.out.println(<span class="number">7</span>);</span><br><span class="line">    <span class="keyword">case</span> THURSDAY, SATURDAY     -&gt; System.out.println(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">case</span> WEDNESDAY              -&gt; System.out.println(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>记录类型（Record Type）的引入</strong></p>
<h2 id="java15新特性"><a href="#java15新特性" class="headerlink" title="java15新特性"></a>java15新特性</h2><p>Text Blocks标准化</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/16/java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://yoursite.com/2020/04/16/java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/program/">program</a></div><div class="post_share"><div class="social-share" data-image="/img/cat.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/17/java%E9%9B%86%E5%90%88/"><img class="prev_cover lazyload" data-src="/img/cat.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">java集合</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><script id="utterances_comment" src="https://utteranc.es/client.js" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script><script>var themeNow = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
document.getElementById('utterances_comment').setAttribute('theme',themeNow)

function utterancesTheme () {
var theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
const message = {
  type: 'set-theme',
  theme: theme
};
const iframe = document.querySelector('.utterances-frame');
iframe.contentWindow.postMessage(message, 'https://utteranc.es');
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Lin</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script></body></html>