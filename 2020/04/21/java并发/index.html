<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java并发 | LIN is keeping learning</title><meta name="description" content="java并发"><meta name="keywords" content="java"><meta name="author" content="Lin"><meta name="copyright" content="Lin"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java并发"><meta name="twitter:description" content="java并发"><meta name="twitter:image" content="http://yoursite.com/img/cat.jpg"><meta property="og:type" content="article"><meta property="og:title" content="java并发"><meta property="og:url" content="http://yoursite.com/2020/04/21/java%E5%B9%B6%E5%8F%91/"><meta property="og:site_name" content="LIN is keeping learning"><meta property="og:description" content="java并发"><meta property="og:image" content="http://yoursite.com/img/cat.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/04/21/java%E5%B9%B6%E5%8F%91/"><link rel="prev" title="算法 java,go实现" href="http://yoursite.com/2020/04/25/%E7%AE%97%E6%B3%95-java%E5%AE%9E%E7%8E%B0/"><link rel="next" title="java图像编程" href="http://yoursite.com/2020/04/21/java%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://linbener.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"爱国,敬业,友善,诚实,自由,平等,和谐","fontSize":"12px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/tou.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#中断线程"><span class="toc-number">1.0.1.</span> <span class="toc-text">中断线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程状态"><span class="toc-number">1.0.2.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程属性"><span class="toc-number">1.0.3.</span> <span class="toc-text">线程属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同步"><span class="toc-number">2.</span> <span class="toc-text">同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#锁对象"><span class="toc-number">2.0.1.</span> <span class="toc-text">锁对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件对象"><span class="toc-number">2.0.2.</span> <span class="toc-text">条件对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized关键字"><span class="toc-number">2.0.3.</span> <span class="toc-text">synchronized关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同步阻塞"><span class="toc-number">2.0.4.</span> <span class="toc-text">同步阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Volatile域"><span class="toc-number">2.0.5.</span> <span class="toc-text">Volatile域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性"><span class="toc-number">2.0.6.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程局部变量"><span class="toc-number">2.0.7.</span> <span class="toc-text">线程局部变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读写锁"><span class="toc-number">2.0.8.</span> <span class="toc-text">读写锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#阻塞队列"><span class="toc-number">2.1.</span> <span class="toc-text">阻塞队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程安全的集合"><span class="toc-number">3.</span> <span class="toc-text">线程安全的集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-util-concurrent包"><span class="toc-number">3.0.1.</span> <span class="toc-text">java.util.concurrent包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#映射条目的原子更新"><span class="toc-number">3.0.2.</span> <span class="toc-text">映射条目的原子更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对并发散列映射的批操作"><span class="toc-number">3.0.3.</span> <span class="toc-text">对并发散列映射的批操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并发集视图"><span class="toc-number">3.0.4.</span> <span class="toc-text">并发集视图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程-1"><span class="toc-number">3.1.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#执行器"><span class="toc-number">3.2.</span> <span class="toc-text">执行器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-number">3.3.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#预定任务"><span class="toc-number">3.4.</span> <span class="toc-text">预定任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制任务组"><span class="toc-number">3.5.</span> <span class="toc-text">控制任务组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#fork-join框架"><span class="toc-number">3.5.1.</span> <span class="toc-text">fork join框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CompletableFuture"><span class="toc-number">3.5.2.</span> <span class="toc-text">CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步器"><span class="toc-number">3.6.</span> <span class="toc-text">同步器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终止线程的方法"><span class="toc-number">4.</span> <span class="toc-text">终止线程的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java并发基础知识"><span class="toc-number">5.</span> <span class="toc-text">Java并发基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的交流管道方式"><span class="toc-number">5.1.</span> <span class="toc-text">线程的交流管道方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#等待通知常用的框架"><span class="toc-number">5.2.</span> <span class="toc-text">等待通知常用的框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LockSupport工具类"><span class="toc-number">5.3.</span> <span class="toc-text">LockSupport工具类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java提供的13中原子性操作类"><span class="toc-number">6.</span> <span class="toc-text">Java提供的13中原子性操作类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java的并发工具类"><span class="toc-number">7.</span> <span class="toc-text">java的并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#等待多线程完成的CountDownLatch"><span class="toc-number">7.1.</span> <span class="toc-text">等待多线程完成的CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步屏障CyclicBarrier"><span class="toc-number">7.2.</span> <span class="toc-text">同步屏障CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#控制并发线程数的Semaphore"><span class="toc-number">7.3.</span> <span class="toc-text">控制并发线程数的Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程间交互数据的Exchanger"><span class="toc-number">7.4.</span> <span class="toc-text">线程间交互数据的Exchanger</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池-1"><span class="toc-number">8.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#向线程池提供任务"><span class="toc-number">8.1.</span> <span class="toc-text">向线程池提供任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的监控"><span class="toc-number">8.2.</span> <span class="toc-text">线程池的监控</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池的创建-ThreadPoolExecutor"><span class="toc-number">8.3.</span> <span class="toc-text">线程池的创建 ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-什么是线程？"><span class="toc-number">8.3.1.</span> <span class="toc-text">1) 什么是线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-线程和进程有什么区别？"><span class="toc-number">8.3.2.</span> <span class="toc-text">2) 线程和进程有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-如何在Java中实现线程？"><span class="toc-number">8.3.3.</span> <span class="toc-text">3) 如何在Java中实现线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-用Runnable还是Thread？"><span class="toc-number">8.3.4.</span> <span class="toc-text">4) 用Runnable还是Thread？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-Thread-类中的start-和-run-方法有什么区别？"><span class="toc-number">8.3.5.</span> <span class="toc-text">6) Thread 类中的start() 和 run() 方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-Java中Runnable和Callable有什么不同？"><span class="toc-number">8.3.6.</span> <span class="toc-text">7) Java中Runnable和Callable有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-Java中的volatile-变量是什么？"><span class="toc-number">8.3.7.</span> <span class="toc-text">8) Java中的volatile 变量是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-什么是线程安全？Vector是一个线程安全类吗？"><span class="toc-number">8.3.8.</span> <span class="toc-text">11) 什么是线程安全？Vector是一个线程安全类吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-Java中notify-和-notifyAll有什么区别？"><span class="toc-number">8.3.9.</span> <span class="toc-text">12) Java中notify 和 notifyAll有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><span class="toc-number">8.3.10.</span> <span class="toc-text">17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-什么是ThreadLocal变量？"><span class="toc-number">8.3.11.</span> <span class="toc-text">18) 什么是ThreadLocal变量？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-什么是FutureTask？"><span class="toc-number">8.3.12.</span> <span class="toc-text">19) 什么是FutureTask？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-Java中interrupted-和-isInterruptedd方法的区别？"><span class="toc-number">8.3.13.</span> <span class="toc-text">20) Java中interrupted 和 isInterruptedd方法的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-为什么wait和notify方法要在同步块中调用？"><span class="toc-number">8.3.14.</span> <span class="toc-text">21) 为什么wait和notify方法要在同步块中调用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-为什么你应该在循环中检查等待条件"><span class="toc-number">8.3.15.</span> <span class="toc-text">22) 为什么你应该在循环中检查等待条件?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-Java中的同步集合与并发集合有什么区别？"><span class="toc-number">8.3.16.</span> <span class="toc-text">23) Java中的同步集合与并发集合有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24）-Java中堆和栈有什么不同？"><span class="toc-number">8.3.17.</span> <span class="toc-text">24） Java中堆和栈有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25）-什么是线程池？-为什么要使用它？"><span class="toc-number">8.3.18.</span> <span class="toc-text">25） 什么是线程池？ 为什么要使用它？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26）-如何写代码来解决生产者消费者问题？"><span class="toc-number">8.3.19.</span> <span class="toc-text">26） 如何写代码来解决生产者消费者问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27）-如何避免死锁？"><span class="toc-number">8.3.20.</span> <span class="toc-text">27） 如何避免死锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-Java中活锁和死锁有什么区别？"><span class="toc-number">8.3.21.</span> <span class="toc-text">28) Java中活锁和死锁有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29）-怎么检测一个线程是否拥有锁？"><span class="toc-number">8.3.22.</span> <span class="toc-text">29） 怎么检测一个线程是否拥有锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30-你如何在Java中获取线程堆栈？"><span class="toc-number">8.3.23.</span> <span class="toc-text">30) 你如何在Java中获取线程堆栈？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-JVM中哪个参数是用来控制线程的栈堆栈小的"><span class="toc-number">8.3.24.</span> <span class="toc-text">31) JVM中哪个参数是用来控制线程的栈堆栈小的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32）-Java中synchronized-和-ReentrantLock-有什么不同？"><span class="toc-number">8.3.25.</span> <span class="toc-text">32） Java中synchronized 和 ReentrantLock 有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33）-有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><span class="toc-number">8.3.26.</span> <span class="toc-text">33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-Thread类中的yield方法有什么作用？"><span class="toc-number">8.3.27.</span> <span class="toc-text">34) Thread类中的yield方法有什么作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35）-Java中ConcurrentHashMap的并发度是什么？"><span class="toc-number">8.3.28.</span> <span class="toc-text">35） Java中ConcurrentHashMap的并发度是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36）-Java中Semaphore是什么？"><span class="toc-number">8.3.29.</span> <span class="toc-text">36） Java中Semaphore是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37）如果你提交任务时，线程池队列已满。会时发会生什么？"><span class="toc-number">8.3.30.</span> <span class="toc-text">37）如果你提交任务时，线程池队列已满。会时发会生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38-Java线程池中submit-和-execute-方法有什么区别？"><span class="toc-number">8.3.31.</span> <span class="toc-text">38) Java线程池中submit() 和 execute()方法有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-什么是阻塞式方法？"><span class="toc-number">8.3.32.</span> <span class="toc-text">39) 什么是阻塞式方法？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#40-Swing是线程安全的吗？-为什么？"><span class="toc-number">8.3.33.</span> <span class="toc-text">40) Swing是线程安全的吗？ 为什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41）-Java中invokeAndWait-和-invokeLater有什么区别？"><span class="toc-number">8.3.34.</span> <span class="toc-text">41） Java中invokeAndWait 和 invokeLater有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-Swing-API中那些方法是线程安全的？"><span class="toc-number">8.3.35.</span> <span class="toc-text">42) Swing API中那些方法是线程安全的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-如何在Java中创建Immutable对象？"><span class="toc-number">8.3.36.</span> <span class="toc-text">43) 如何在Java中创建Immutable对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#44）-Java中的ReadWriteLock是什么？"><span class="toc-number">8.3.37.</span> <span class="toc-text">44） Java中的ReadWriteLock是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#45-多线程中的忙循环是什么"><span class="toc-number">8.3.38.</span> <span class="toc-text">45) 多线程中的忙循环是什么?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#46）volatile-变量和-atomic-变量有什么不同？"><span class="toc-number">8.3.39.</span> <span class="toc-text">46）volatile 变量和 atomic 变量有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#47-如果同步块内的线程抛出异常会发生什么？"><span class="toc-number">8.3.40.</span> <span class="toc-text">47) 如果同步块内的线程抛出异常会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48）-单例模式的双检锁是什么？"><span class="toc-number">8.3.41.</span> <span class="toc-text">48） 单例模式的双检锁是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49）-如何在Java中创建线程安全的Singleton？"><span class="toc-number">8.3.42.</span> <span class="toc-text">49） 如何在Java中创建线程安全的Singleton？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#50-写出3条你遵循的多线程最佳实践"><span class="toc-number">8.3.43.</span> <span class="toc-text">50) 写出3条你遵循的多线程最佳实践</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#51-如何强制启动一个线程？"><span class="toc-number">8.3.44.</span> <span class="toc-text">51) 如何强制启动一个线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#52-Java中的fork-join框架是什么？"><span class="toc-number">8.3.45.</span> <span class="toc-text">52) Java中的fork join框架是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#53）-Java多线程中调用wait-和-sleep-方法有什么不同？"><span class="toc-number">8.3.46.</span> <span class="toc-text">53） Java多线程中调用wait() 和 sleep()方法有什么不同？</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/cat.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">LIN is keeping learning</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">java并发</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-04-21 18:41:22"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-04-21</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-09-15 22:51:49"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-09-15</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><p>线程的终止只有两种情况，一是线程正常退出，二是线程出现异常。</p>
<p>在Thread对象中，没有方法可以让线程停止运行，但是可以请求线程中断，interrupt方法就是将线程的中断状态置位。请求中断的线程如果之后调用线程休眠sleep，那么会发生中断异常。</p>
<p>static boolean interrupted ()</p>
<p>测试当前线程 （ 即正在执行这一命令的线程 ） 是否被中断。 注意 ， 这是一个静态方法 。这一调用会产生副作用 是它将当前线程的中断状态重置为 false。</p>
<p>boolean islnterrupted ()<br>测试线程是否被终止， 不像静态的中断方法 ， 这一调用不改变线程的中断状态 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable runnable=()-&gt;&#123;</span><br><span class="line">    Thread thread=Thread.currentThread();</span><br><span class="line">    String name=Thread.currentThread().getName();</span><br><span class="line">    System.out.println(name+<span class="string">"  "</span>+thread.getState());<span class="comment">//运行状态</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(thread.isInterrupted());<span class="comment">//false</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        System.out.println(thread.isInterrupted());<span class="comment">//true</span></span><br><span class="line">      <span class="comment">//  System.out.println(Thread.interrupted()); 结果为true，并把状态位重置为false,之后调用sleep,不会发生异常，因为方法的副作用。</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//在thread.interrupt()调用之后，发生了异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(thread.getState());<span class="comment">//运行状态</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Thread t=<span class="keyword">new</span> Thread(runnable);</span><br><span class="line">System.out.println(Thread.currentThread().getName());</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><ol>
<li>New</li>
<li>Runnable</li>
<li>Blocked</li>
<li>Waiting</li>
<li>Timed waiting 计时等待</li>
<li>Terminated</li>
</ol>
<p>获取线程状态的方法是<code>getState()</code></p>
<p>可运行线程，一旦调用了start方法，线程就处于runnable，但是线程可运行不代表它一直处于运行状态，这取决于操作系统分配给它的时间片。</p>
<p>被阻塞线程和等待线程</p>
<p><strong>阻塞线程</strong></p>
<p>当一个<strong>线程试图获取一个内部的对象锁时</strong>，但锁被其他线程持有，所以该线程为了获取锁，进入阻塞状态，直到线程调度器允许该线程拿到锁，该线程变成非阻塞状态。</p>
<p><strong>等待线程</strong></p>
<p>当一个线程<strong>等待另一个线程通知调度器的一个条件</strong>时，它进入等待状态。 比如调用Object.wait() 或Thread.join() </p>
<p>java.util.concurrent库中的Lock或 Condition时。</p>
<p>有几个方法有一个<strong>超时参数</strong>，调用这些方法导致它们进入计时等待状态，这状态直到时间超过超时参数，或者收到通知，它们就会解除该状态。 方法，<code>Thread.sleep Object.wait Thread.join Lock.tryLock Condition.wait</code></p>
<p>阻塞线程和等待线程有很大的不同。</p>
<h4 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h4><p>线程优先级</p>
<p>默认情况下，一个线程的优先级继承父线程的优先级。</p>
<p><code>setPriority</code> 线程的优先级为5 ，MIN_PRIORITY=1 MAX_PRIORITY=10</p>
<p>windows系统有7个优先级，这时Java就会忽略掉自己的某些优先级，但优先级不常常有效。</p>
<p>守护线程</p>
<p>setDaemon 守护线程的作用是为其他线程提供服务，计时线程就是一个例子</p>
<p>处理未捕获异常的处理器</p>
<p>线程的run方法不能抛出任何的非受检查的异常，发生了非受检查的异常，线程就死亡了，如果线程想要处理这种异常，就要继承 <code>Thread.UncaughtExceptionHandler</code> 接口的类</p>
<h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><h4 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h4><p>在临界资源的前后，使用锁机制避免同一时间内超过两个以上的线程进入代码块。</p>
<p>Java中的锁对象是<code>java.util.concurrent.locks.ReentrantLock</code></p>
<p>使用时声明它为不可变的成员变量即可，用new创建实例，成员变量的lock unlock方法在资源的前后上锁和解锁。通常格式为  lock   try{  }finally{   unlock }</p>
<h4 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h4><p><code>java.util.concurrent.locks.Condition</code></p>
<p>在上锁之后，进入临界资源需要满足一定的条件，如果不满足条件就需要等待，线程进入等待队列，等到其他的线程通知。</p>
<p><strong>Condition实例需要ReentrantLock的实例对象调用<code>newCondition()</code>方法获取</strong>。</p>
<p>条件的判断用while进行判断，如果不满足调用Condition实例对象的wait方法，在解锁前需要调用实例对象的signalAll方法，唤醒等待的全部线程，signal方法会随机唤醒某一个线程，如果唤醒的线程还是不满足条件那么会继续等待，但此时没有线程运行，那么就会陷入死锁，所以为了避免死锁，一般选用signalAll方法。</p>
<p>一个例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] account;</span><br><span class="line">    <span class="keyword">private</span> Lock bankLock=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">        account=<span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        Arrays.fill(account,money);</span><br><span class="line">        condition=bankLock.newCondition();<span class="comment">//获取条件变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> from,<span class="keyword">int</span> to,<span class="keyword">double</span> money)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        if(account[from]&lt;money)&#123;</span></span><br><span class="line"><span class="comment">//            return;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        bankLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (account[from]&lt;money)</span><br><span class="line">            &#123;</span><br><span class="line">                condition.await();<span class="comment">//进入等待状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"---"</span>+bankLock.hashCode());</span><br><span class="line">            account[from] -= money;</span><br><span class="line">            System.out.println(String.format(<span class="string">"%10.2f form %d to %d"</span>, money, from, to));</span><br><span class="line">            account[to] += money;</span><br><span class="line">            System.out.println(<span class="string">"total money  ="</span> + getTotal());</span><br><span class="line">            condition.signalAll();<span class="comment">//唤醒等待的全部线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">        bankLock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> a : account) &#123;</span><br><span class="line">                sum += a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                bankLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> account.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">double</span> a : account) &#123;</span><br><span class="line">        sum += a;</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.intrinsicLock.lock();<span class="comment">//实际上没有intrinsicLock，这里只是为了便于理解。</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">double</span> a : account) &#123;</span><br><span class="line">            sum += a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.intrinsicLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized可以说是封装lock和condition的封装器，本质上还是lock,condition在底层起作用。</p>
<p><strong>对象wait,notifyAll,notify和条件变量的方法一致，唯一的区别就是不用显示地生成条件变量。</strong></p>
<p>静态方法用synchronized关键词修饰也是可以的，静态同步方法被调用时，Bank.class对象的锁被锁住。</p>
<h4 id="同步阻塞"><a href="#同步阻塞" class="headerlink" title="同步阻塞"></a>同步阻塞</h4><p>每一个Java对象都有一个锁，线程可以调用同步方法获得锁，也可以采用另一种机制获得锁，就是<strong>同步阻塞</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">double</span> a : account) &#123;</span><br><span class="line">               sum += a;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> sum;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//  这里即可以获得this对象本身的锁，也可以获取成员变量或者方法参数的锁，获取方法参数的锁被称为客户端锁定</span></span><br><span class="line">code...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Volatile域"><a href="#Volatile域" class="headerlink" title="Volatile域"></a>Volatile域</h4><p>volatile关键词为实例域同步访问提供了一种免锁机制。<strong>它让线程访问volatile变量永远都是最新的。</strong></p>
<p><strong>但是volatile变量不能提供原子性，不能确保翻转域中的值。不能保证读取 ，翻转和写入不被中断 。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sum=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(<span class="keyword">double</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum +<span class="keyword">this</span>.sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vo v=<span class="keyword">new</span> Vo();</span><br><span class="line"></span><br><span class="line">        Runnable r=()-&gt;&#123;v.setSum(<span class="number">1</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"  ---"</span>+v.getSum());&#125;;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">            Thread thread=<span class="keyword">new</span> Thread(r);</span><br><span class="line">            thread.start();</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread-8  ---9.0</span></span><br><span class="line"><span class="comment">//Thread-7  ---8.0</span></span><br><span class="line"><span class="comment">//Thread-3  ---4.0</span></span><br><span class="line"><span class="comment">//Thread-2  ---3.0</span></span><br><span class="line"><span class="comment">//Thread-1  ---2.0</span></span><br><span class="line"><span class="comment">//Thread-6  ---7.0</span></span><br><span class="line"><span class="comment">//Thread-0  ---2.0</span></span><br><span class="line"><span class="comment">//Thread-4  ---5.0</span></span><br><span class="line"><span class="comment">//Thread-9  ---10.0</span></span><br><span class="line"><span class="comment">//Thread-5  ---6.0</span></span><br><span class="line"><span class="comment">//很惊讶是吗？我们让volatile变量自增10次，线程9的结果为10正合乎我们的本意，但是线程0和1输出的结果却为2，这是为什么？</span></span><br><span class="line">上面我们说了<span class="keyword">volatile</span>域让线程访问的变量永远都是最新值，但getSum获取值时，由于线程的随机运行使得线程<span class="number">0</span>访问<span class="keyword">volatile</span>变量不是它增加后的<span class="number">1</span>，而是线程<span class="number">1</span>更新后的最新值<span class="number">2</span>。这也是<span class="keyword">volatile</span>不能提供原子性的原因，不安全。</span><br></pre></td></tr></table></figure>

<p>但在部分场景volatile域也是能用的。</p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p><code>java.util.concurrent.atomic</code></p>
<p>包下有许多的类的方法操作都是原子性的，在并发过程中保证了原子操作。</p>
<h4 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h4><p> java.util.Random类是线程安全的,但是如果多个线程需要等待一个共享的随机数生成器 , 这会很低效。</p>
<p>可以使用ThreadLocalRandom辅助类为每一个线程单独生成一个Random类实例。</p>
<p>总所周知SimpleDateFormat并不是线程安全的，单线程的情况下是安全的，但多线程的情况下，将会发生数据缭乱。</p>
<p><strong>线程局部辅助类<code>ThreadLocal</code>可以为每一个线程生成各自的实例。</strong></p>
<p>ThreadLocal的实现原理是一个map,它的键是每个进程的IP，通过get,set方法直接能换取值。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>锁超时tryLock() 返回布尔类型，如果获得锁为真，没有获得锁就可以去做其他的事情。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取锁</span><br><span class="line">private ReentrantReadWriteLock reentrantReadWriteLock&#x3D;new ReentrantReadWriteLock();</span><br><span class="line">&#x2F;&#x2F;抽取读写锁</span><br><span class="line">private Lock read&#x3D;reentrantReadWriteLock.readLock();</span><br><span class="line">private Lock write&#x3D;reentrantReadWriteLock.writeLock();</span><br></pre></td></tr></table></figure>

<p><strong>读锁和写锁的操作和锁用法都是在临界资源前后上锁和解锁。</strong></p>
<p><strong>与普通的锁不同的是，读锁排斥写锁，写锁排斥读锁和其他的写锁。</strong></p>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>对于多线程问题，如果是生产者和消费者问题，可以使用阻塞队列替代同步方法，使得数据同步。</p>
<p>生产者向队尾添加元素，消费者从队头取出元素，当队列满时添加元素，或队列空时取出元素，阻塞队列导致线程阻塞。</p>
<p>add,remove,element在队列满或空时操作会抛出异常，所以不要用这些方法。</p>
<p>而是阻塞队列当管理工具使用采用put take方法，多线程采用 offer poll peek</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>抛出异常</th>
<th>返回特殊值</th>
<th>一直阻塞</th>
<th>超时退出</th>
</tr>
</thead>
<tbody><tr>
<td>插入方法</td>
<td>add</td>
<td>offer</td>
<td>put</td>
<td>offer</td>
</tr>
<tr>
<td>移除方法</td>
<td>remove</td>
<td>poll</td>
<td>take</td>
<td>poll</td>
</tr>
<tr>
<td>检查方法</td>
<td>element</td>
<td>peel</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>方法。</p>
<ol>
<li><strong>ArrayBlockingQueue</strong> ：一个由数组结构组成的有界阻塞队列。</li>
<li><strong>LinkedBlockingQueue</strong> ：一个由链表结构组成的有界阻塞队列。</li>
<li><strong>PriorityBlockingQueue</strong> ：一个支持优先级排序的无界阻塞队列。</li>
<li><strong>DelayQueue</strong>：一个使用优先级队列实现的无界阻塞队列。</li>
<li><strong>SynchronousQueue</strong>：一个不存储元素的阻塞队列。</li>
<li><strong>LinkedTransferQueue</strong>：一个由链表结构组成的无界阻塞队列。</li>
<li><strong>LinkedBlockingDeque</strong>：一个由链表结构组成的双向阻塞队列</li>
</ol>
<h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><h4 id="java-util-concurrent包"><a href="#java-util-concurrent包" class="headerlink" title="java.util.concurrent包"></a>java.util.concurrent包</h4><p><code>ConcurrentHashMap</code> <code>ConcurrentLinkedDeque</code>等映射，集合都是线程安全的，它们允许并发线程访问集合的不同部分使得竞争最小化。</p>
<p><strong>确认这些集合的大小只能通过遍历得到，而不是普通的size方法。</strong>  Java8之后映射的大小可以使用mappingCount方法确认。</p>
<p>集合返回弱一致性的迭代器，迭代器只能反映生成它时集合之前的数据。</p>
<h4 id="映射条目的原子更新"><a href="#映射条目的原子更新" class="headerlink" title="映射条目的原子更新"></a>映射条目的原子更新</h4><p>compute，merge 方法传入的函数如果返回值为空，那么就会删除原来的键值对。</p>
<h4 id="对并发散列映射的批操作"><a href="#对并发散列映射的批操作" class="headerlink" title="对并发散列映射的批操作"></a>对并发散列映射的批操作</h4><p><strong>即使其他线程在处理映射，这些批操作也能正确执行。</strong></p>
<ol>
<li>搜索：为每一个键/值提供一个函数，直到函数返回值不为空时，搜索终止，返回结果</li>
<li>归约：组合所以的键值，提供的函数是<strong>累加函数</strong></li>
<li>forEach：为所有的键值提供函数</li>
</ol>
<p>每个操作都有四个版本，处理键 处理值 处理键值 处理Map.Entry</p>
<p>对于上述的操作，都要给方法传递第一个参数threshold为阀值，只有集合内大小超过这个阀值，就会自动采用多线程执行。</p>
<h4 id="并发集视图"><a href="#并发集视图" class="headerlink" title="并发集视图"></a>并发集视图</h4><p>想要的不是集合而是视图，那么可是使用ConcurrentHashMap的静态反法，newKeySet会生成一个 Set &lt; K &gt; ，实际上这是一个 ConcurrentHashMap &lt; K , Boolean &gt;的一个包装器。(所有映射值都为 Boolean .TRUE , 不过因为只是要把它用作一个集， 所以并不关心具体的值。</p>
<p>写数组的拷贝 并行数组的算法</p>
<p>CopyOnWriteArrayList CopyOnWriteArraySet是线程安全的集合</p>
<p>从Java8开始，<strong>Arrays</strong>类提供了大量的并行化操作，如parallelSort</p>
<h3 id="线程-1"><a href="#线程-1" class="headerlink" title="线程"></a>线程</h3><p>Runnable接口</p>
<p>Callable接口和Runnable类似，接口的方法是call，有一个返回值。</p>
<p>Future接口，保存异步计算的结果，可以得到线程返回的结果，有get cancel isDone isCancel等方法。</p>
<p>FutureTask包装器，可以将Callable转换成Runnable 和Future</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">     ExecutorService service=Executors.newCachedThreadPool();</span><br><span class="line">     Callable&lt;Integer&gt; callable=()-&gt;<span class="number">8</span>*<span class="number">9</span>;</span><br><span class="line">     FutureTask&lt;Integer&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;&gt;(callable); <span class="comment">//封装callable</span></span><br><span class="line">     <span class="keyword">new</span> Thread(futureTask).start();<span class="comment">//当作runnbale</span></span><br><span class="line">    System.out.println(futureTask.get());<span class="comment">//future.get的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>Executor类有许多的静态工厂方法用来构建线程池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executors.newCachedThreadPool();</span><br><span class="line">Executors.newSingleThreadExecutor();</span><br><span class="line">Executors.newFixedThreadPool(<span class="number">12</span>);</span><br><span class="line">Executors.newScheduledThreadPool(<span class="number">12</span>); <span class="comment">//预定执行的固定线程池</span></span><br><span class="line">Executors.newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure>



<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><strong>ExecutorService</strong>接口用来接受构建的线程池,submit方法向线程池提交任务</p>
<h3 id="预定任务"><a href="#预定任务" class="headerlink" title="预定任务"></a>预定任务</h3><p><strong>ScheduledExecutorService</strong>接口  具有用于预定任务或者重复执行的任务的方法</p>
<ol>
<li>schedule 预定在指定的时间之后执行任务</li>
<li>scheduleAtFixedRate 预定在初始的延迟结束后 ， 周期性地运行给定的任务 ， 周期长度是 period</li>
<li>scheduleWithFixedDelay 同上一个方法一样，只不过在周期性执行相同方法中间存在一个时间延迟</li>
</ol>
<h3 id="控制任务组"><a href="#控制任务组" class="headerlink" title="控制任务组"></a>控制任务组</h3><p>invokeAny  提交一个 Callable 对象的集合给线程池 ， 并返回某个已经完成了的任务的结果。 无法知道返回的究竟是哪个任务的结果 ，也许是最先完成的那个任务的结果。对于搜索问题 ， 如果你愿意接受任何一种解决方案的话，你就可以使用这个方法 。 </p>
<p>invokeAll 同上方法，只不过返回所有任务的结果。</p>
<h4 id="fork-join框架"><a href="#fork-join框架" class="headerlink" title="fork join框架"></a>fork join框架</h4><p>处理密集型的任务，而该任务能够分解成多个子任务，子任务的join的结果就是任务的结果。</p>
<p>想要采用这种框架就要继承RecursiveTask&lt; T &gt;类或者 RecursiveActicn类</p>
<p>RecursiveTask类的compute 内的invokeAll方法接受分解的两个子任务并阻塞，直到所有的子任务返回结果。</p>
<p>不允许使用get方法得到子任务的结果，因为它会抛出异常，而compute方法不允许破除异常，所有用join。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> threshold ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> segmentation = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] src;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fromIndex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> toIndex;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SumTask</span><span class="params">(<span class="keyword">int</span> formIndex,<span class="keyword">int</span> toIndex,<span class="keyword">int</span>[] src)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fromIndex = formIndex;</span><br><span class="line">        <span class="keyword">this</span>.toIndex = toIndex;</span><br><span class="line">        <span class="keyword">this</span>.src = src;</span><br><span class="line">        <span class="keyword">this</span>.threshold = src.length/segmentation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果该条件满足，那么直接把执行任务，得到结果</span></span><br><span class="line">        <span class="keyword">if</span>((toIndex - fromIndex)&lt;threshold )&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            System.out.println(<span class="string">" from index = "</span>+fromIndex</span><br><span class="line">                    +<span class="string">" toIndex="</span>+toIndex);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = fromIndex;i&lt;=toIndex;i++)&#123;</span><br><span class="line">                count+=src[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count; <span class="comment">//join得到的结果</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//条件不满足，拆分任务得到两个子任务</span></span><br><span class="line">            <span class="keyword">int</span> mid = (fromIndex+toIndex)/<span class="number">2</span>;</span><br><span class="line">            SumTask left =  <span class="keyword">new</span> SumTask(fromIndex,mid,src);</span><br><span class="line">            SumTask right = <span class="keyword">new</span> SumTask(mid+<span class="number">1</span>,toIndex,src);</span><br><span class="line">            <span class="comment">//将子任务插入线程池，执行子任务</span></span><br><span class="line">            invokeAll(left,right);</span><br><span class="line">            <span class="comment">//返回子任务的结果</span></span><br><span class="line">            <span class="keyword">return</span> left.join()+right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[]  array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">40</span>];</span><br><span class="line">        Arrays.fill(array,<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//专门的线程池</span></span><br><span class="line">        ForkJoinPool forkJoinPool= <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        SumTask sumTask  = <span class="keyword">new</span> SumTask(<span class="number">0</span>,array.length-<span class="number">1</span>,array);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">        forkJoinPool.invoke(sumTask);</span><br><span class="line">        System.out.println(<span class="string">"The count is "</span>+sumTask.join()</span><br><span class="line">                +<span class="string">" spend time:"</span>+(System.currentTimeMillis()-start)+<span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RecursiveTask 和RecursiveActicn相比compute方法，有返回值。</strong></p>
<p><strong>ForkJoinPool</strong> 专门使用的线程池，在执行过程中可能会抛出异常，但没有办法再主线程里直接捕获异常，所以<strong>ForkJoinPool</strong> 提供了isCompletedAbnormally方法检查任务是否一斤抛出异常或者已经被取消。</p>
<h4 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h4><p><strong>ExecutorCompletionService</strong></p>
<p>可完成式的Future接口，Java8提供的代替Future的接口。</p>
<h3 id="同步器"><a href="#同步器" class="headerlink" title="同步器"></a>同步器</h3><p><code>java.util.concurrent</code> 包有几个管理相互合作的线程集的类。</p>
<p>如果一个相互合作的线程集满足以下的条件，那应该使用这些类。</p>
<table>
<thead>
<tr>
<th>class</th>
<th>what it do</th>
<th>explanation</th>
</tr>
</thead>
<tbody><tr>
<td>CyclicBarrier</td>
<td>允许线程集等待直至其中预定数目的线程到达一个公共障栅 （ barrier )， 然后可以选择执行一个处理障栅的动作</td>
<td>当大量的线程需要在它们的结果可用之前完成时</td>
</tr>
<tr>
<td>Phaser</td>
<td>类似于循环障栅 ， 不过有一个可变的计数</td>
<td></td>
</tr>
<tr>
<td>CountDownLatch</td>
<td>允许线程集等待直到计数器减为 0</td>
<td>当一个或多个线程需要等待直到指定数目的事件发生</td>
</tr>
<tr>
<td>Exchanger</td>
<td>允许两个线程在要交换的对象准备好时交换对象</td>
<td></td>
</tr>
<tr>
<td>Semaphore</td>
<td>允许线程集等待直到被允许继续运行为止</td>
<td>限制访问资源的线程总数 。 如果许可数是 1 .常常阻塞线程直到另一个线程给出许可为止</td>
</tr>
<tr>
<td>SynchronousQueue</td>
<td>允许一个线程把对象交给另一个线程</td>
<td>在没有显式同步的情况下 ， 当两个线程准备，好将一个对象从一个线程传递到另一个时</td>
</tr>
</tbody></table>
<h2 id="终止线程的方法"><a href="#终止线程的方法" class="headerlink" title="终止线程的方法"></a>终止线程的方法</h2><p>通过线程的中断操作或者标识位的方式能够在线程终止前，让线程有机会去清除线程的资源，这种方式更加优雅。</p>
<p><strong>中断方式</strong></p>
<p>通过线程的方法 interrupt() Thread.currentThread.isInterrupted() 方式中断前程</p>
<p>run方法内部要用while判断Thread.currentThread.isInterrupted() 是否中断</p>
<p><strong>通过标识位</strong></p>
<p>在继承runner接口的类，设置一个布尔类型的变量,而这个变量用volatile修饰，并提供方法改变这个变量的值，在run方法内部用while判断该变量的值为真时，才能执行</p>
<h2 id="Java并发基础知识"><a href="#Java并发基础知识" class="headerlink" title="Java并发基础知识"></a>Java<strong>并发基础知识</strong></h2><p>线程的锁的本质是监视器monitor，只有获得监视器才能访问Object</p>
<h3 id="线程的交流管道方式"><a href="#线程的交流管道方式" class="headerlink" title="线程的交流管道方式"></a>线程的交流管道方式</h3><p>管道有两种 一是面向字节，一是面向字符</p>
<p>Piped 管道是线程之间相互交互信息的方式，是用内存交互</p>
<p>管道输出流要用connect方法和输入流绑定</p>
<h3 id="等待通知常用的框架"><a href="#等待通知常用的框架" class="headerlink" title="等待通知常用的框架"></a>等待通知常用的框架</h3><p>1获取锁 2 用while循环判断条件 3 根据相应的条件使用wait notify notifyAll</p>
<p>Lock接口 面对锁的使用者 <strong>同步器AbstractQueuedSynchronizer</strong> 面对锁的实现者</p>
<p>同步器一般有实现三个重要的方法，分别是获取状态，设置状态，以原子性设置状态</p>
<p>自定义实现某个同步器类</p>
<p>该个类要扩展Lock接口，而且拥有一个静态内部类，这个静态内部类继承同步器AbstractQueuedSynchronizer</p>
<p>重入锁ReentrantLock</p>
<p>读写锁ReentrantReadWriteLock</p>
<h3 id="LockSupport工具类"><a href="#LockSupport工具类" class="headerlink" title="LockSupport工具类"></a><strong>LockSupport工具类</strong></h3><p>定义了一组公共的静态方法，这些方法提供了最基本的线程阻塞和唤醒功能。</p>
<p>阻塞的方法以park为开头，唤醒的方法以unpark为开头。</p>
<h2 id="Java提供的13中原子性操作类"><a href="#Java提供的13中原子性操作类" class="headerlink" title="Java提供的13中原子性操作类"></a>Java提供的13中原子性操作类</h2><p>java.util.concurrent.atomic包</p>
<p>原子更新基本类型</p>
<p>AtomicBoolean  AtomicInteger   AtomicLong</p>
<p>原子更新数组</p>
<p>AtomicIntegerArray AtomicLongArray  AtomicReferenceArray  AtomicIntegerArray</p>
<p>原子更新引用</p>
<p>AtomicReference  AtomicReferenceFieldUpdater</p>
<p>原子更新属性</p>
<p>AtomicIntegerFieldUpdater   AtomicLongFieldUpdater   AtomicStampedReference</p>
<h2 id="java的并发工具类"><a href="#java的并发工具类" class="headerlink" title="java的并发工具类"></a>java的并发工具类</h2><h3 id="等待多线程完成的CountDownLatch"><a href="#等待多线程完成的CountDownLatch" class="headerlink" title="等待多线程完成的CountDownLatch"></a>等待多线程完成的CountDownLatch</h3><p>CountDownLatch的构造器需要传入一个N的整数，大于0</p>
<p>CountDownLatch的对象调用countDown方法会使得N减去1 ；调用对象的 await 方法会阻塞当前线程，直到N的个数为0</p>
<h3 id="同步屏障CyclicBarrier"><a href="#同步屏障CyclicBarrier" class="headerlink" title="同步屏障CyclicBarrier"></a>同步屏障CyclicBarrier</h3><p>让一组线程到达一个屏障时被阻塞，屏障也可称为同步点，直到最后一个线程到达同步点时，屏障才会开门。</p>
<p>默认的构造函数要传入一个整数N，代表有多少个线程需要到达屏障</p>
<p>调用CyclicBarrier对象的await方法，告知CyclicBarrier对象已经到达同步点。</p>
<p>高级的构造函数，需要传入一个N和一个Runnable对象，用于线程到达屏障时，优先执行这个</p>
<p>Runnable对象对象。</p>
<p>可以和其他的并发工具搭配，用于处理数据的计算。</p>
<h3 id="控制并发线程数的Semaphore"><a href="#控制并发线程数的Semaphore" class="headerlink" title="控制并发线程数的Semaphore"></a>控制并发线程数的Semaphore</h3><p>Semaphore信号量 用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p>
<p>流量控制 </p>
<p>构造器传入的数量N，代表进入特定资源的线程个数</p>
<p><strong>特定的资源前后要用对象的acquire release方法获取信号量和释放信号量</strong></p>
<h3 id="线程间交互数据的Exchanger"><a href="#线程间交互数据的Exchanger" class="headerlink" title="线程间交互数据的Exchanger"></a>线程间交互数据的Exchanger</h3><p>它提供一个同步点，在这个同步点，两个线程可以交互彼此的数据</p>
<p>通过exchange方法交换数据</p>
<p>如果一个线程先执行了该方法，那么它会一直等待第二个线程也只想该方法。</p>
<p>可以用于遗传算法 银行流水的校对工作</p>
<p><strong>构造函数传入的类型是 交互的数据类型</strong></p>
<p><strong>exchange方法要传入交互的数据，同时返回另一个线程提供的数据</strong></p>
<h2 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h2><p>线程池如果没有足够的线程，处于饱和状态，那么必须采取一种策略处理提交的新任务</p>
<p>这个策略默认情况是AbortPolicy，表示无法处理新任务时抛出异常。</p>
<p>Java提供了4种策略</p>
<p>AbortPolicy</p>
<p>CallerRunsPolicy 只是调用者所在线程来运行任务</p>
<p>DiscardOldestPolicy 丢弃队列里最近一个任务，执行当前任务</p>
<p>DiscardPolicy 不处理，丢弃掉</p>
<h3 id="向线程池提供任务"><a href="#向线程池提供任务" class="headerlink" title="向线程池提供任务"></a>向线程池提供任务</h3><p>两种方法</p>
<p>execute 用于提交不需要返回值的任务</p>
<p>submit 用于提供需要返回值的任务，会返回一个future类型的对象</p>
<h3 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h3><p>相关属性</p>
<p>taskCount</p>
<p>completedTaskCount</p>
<p>largestPoolSize</p>
<p>getPoolSize</p>
<p>getActiveCount</p>
<h3 id="线程池的创建-ThreadPoolExecutor"><a href="#线程池的创建-ThreadPoolExecutor" class="headerlink" title="线程池的创建 ThreadPoolExecutor"></a>线程池的创建 ThreadPoolExecutor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,millseconds,runnableTaskQueue,handler);</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//**</span></span><br><span class="line">runnableTaskQueue任务队列，用于保存等待执行的任务的阻塞队列，可以旋转<span class="number">4</span>种阻塞队列</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>



<p>@多线程面试知识题</p>
<p><a href="https://www.cnblogs.com/xiaowangbangzhu/p/10443289.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaowangbangzhu/p/10443289.html</a></p>
<h4 id="1-什么是线程？"><a href="#1-什么是线程？" class="headerlink" title="1) 什么是线程？"></a>1) 什么是线程？</h4><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。程序员可以通过它进行多处理器编程，你可以使用多线程对 运算密集型任务提速。比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒。Java在语言层面对多线程提供了卓越的支 持，它也是一个很好的卖点。</p>
<h4 id="2-线程和进程有什么区别？"><a href="#2-线程和进程有什么区别？" class="headerlink" title="2) 线程和进程有什么区别？"></a>2) 线程和进程有什么区别？</h4><p>线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。别把它和栈内存搞混，每个线程都拥有单独的栈内存用来存储本地数据。</p>
<h4 id="3-如何在Java中实现线程？"><a href="#3-如何在Java中实现线程？" class="headerlink" title="3) 如何在Java中实现线程？"></a>3) 如何在Java中实现线程？</h4><p>在语言层面有三种方式。java.lang.Thread 类的实例就是一个线程但是它需要调用java.lang.Runnable接口来执行，由于线程类本身就是调用的Runnable接口所以你可以继承 java.lang.Thread 类或者直接调用Runnable接口来重写run()方法实现线程。第三种 实现Callable&lt;&gt;接口并重写call方法。</p>
<h4 id="4-用Runnable还是Thread？"><a href="#4-用Runnable还是Thread？" class="headerlink" title="4) 用Runnable还是Thread？"></a>4) 用Runnable还是Thread？</h4><p>这个问题是上题的后续，大家都知道我们可以通过继承Thread类或者调用Runnable接口来实现线程，问题是，那个方法更好呢？什么情况下使 用它？这个问题很容易回答，如果你知道Java不支持类的多重继承，但允许你调用多个接口。所以如果你要继承其他类，当然是调用Runnable接口好 了。</p>
<h4 id="6-Thread-类中的start-和-run-方法有什么区别？"><a href="#6-Thread-类中的start-和-run-方法有什么区别？" class="headerlink" title="6) Thread 类中的start() 和 run() 方法有什么区别？"></a>6) Thread 类中的start() 和 run() 方法有什么区别？</h4><p>这个问题经常被问到，但还是能从此区分出面试者对Java线程模型的理解程度。start()方法被用来启动新创建的线程，而且start()内部 调用了run()方法，这和直接调用run()方法的效果不一样。当你调用run()方法的时候，只会是在原来的线程中调用，没有新的线程启 动，start()方法才会启动新线程。</p>
<h4 id="7-Java中Runnable和Callable有什么不同？"><a href="#7-Java中Runnable和Callable有什么不同？" class="headerlink" title="7) Java中Runnable和Callable有什么不同？"></a>7) Java中Runnable和Callable有什么不同？</h4><p>Runnable和Callable都代表那些要在不同的线程中执行的任务。Runnable从JDK1.0开始就有了，Callable是在 JDK1.5增加的。它们的主要区别是Callable的 call() 方法可以返回值和抛出异常，而Runnable的run()方法没有这些功能。Callable可以返回装载有计算结果的Future对象。</p>
<h4 id="8-Java中的volatile-变量是什么？"><a href="#8-Java中的volatile-变量是什么？" class="headerlink" title="8) Java中的volatile 变量是什么？"></a>8) Java中的volatile 变量是什么？</h4><p>volatile是一个特殊的修饰符，只有成员变量才能使用它。保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<h4 id="11-什么是线程安全？Vector是一个线程安全类吗？"><a href="#11-什么是线程安全？Vector是一个线程安全类吗？" class="headerlink" title="11) 什么是线程安全？Vector是一个线程安全类吗？"></a>11) 什么是线程安全？Vector是一个线程安全类吗？</h4><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量 的值也和预期的是一样的，就是线程安全的。一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分 成两组，线程安全和非线程安全的。Vector 是用同步方法来实现线程安全的, 而和它相似的ArrayList不是线程安全的。</p>
<h4 id="12-Java中notify-和-notifyAll有什么区别？"><a href="#12-Java中notify-和-notifyAll有什么区别？" class="headerlink" title="12) Java中notify 和 notifyAll有什么区别？"></a>12) Java中notify 和 notifyAll有什么区别？</h4><p>这又是一个刁钻的问题，因为多线程可以等待单监控锁，Java API 的设计人员提供了一些方法当等待条件改变的时候通知它们，但是这些方法没有完全实现。notify()方法不能唤醒某个具体的线程，所以只有一个线程在等 待的时候它才有用武之地。而notifyAll()唤醒所有线程并允许他们争夺锁确保了至少有一个线程能继续运行。</p>
<h4 id="17-为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#17-为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>17) 为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p>这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在 Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通 过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁 就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p>
<h4 id="18-什么是ThreadLocal变量？"><a href="#18-什么是ThreadLocal变量？" class="headerlink" title="18) 什么是ThreadLocal变量？"></a>18) 什么是ThreadLocal变量？</h4><p>ThreadLocal使用场合主要解决多线程中数据数据因并发产生不一致问题。ThreadLocal为每个线程的中并发访问的数据提供一个副本，通过访问副本来运行业务，这样的结果是耗费了内存，单大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。</p>
<p>ThreadLocal不能使用原子类型，只能使用Object类型。ThreadLocal的使用比synchronized要简单得多。</p>
<p>ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别。synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。</p>
<h4 id="19-什么是FutureTask？"><a href="#19-什么是FutureTask？" class="headerlink" title="19) 什么是FutureTask？"></a>19) 什么是FutureTask？</h4><p>在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完 成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包 装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p>
<h4 id="20-Java中interrupted-和-isInterruptedd方法的区别？"><a href="#20-Java中interrupted-和-isInterruptedd方法的区别？" class="headerlink" title="20) Java中interrupted 和 isInterruptedd方法的区别？"></a>20) Java中interrupted 和 isInterruptedd方法的区别？</h4><p>interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用<a href="http://java67.blogspot.com/2012/11/what-is-static-class-variable-method.html" target="_blank" rel="noopener">静态方法</a>Thread.interrupted()来 检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。简单的说就是任何抛 出InterruptedException异常的方法都会将中断状态清零。无论如何，一个线程的中断状态有有可能被其它线程调用中断来改变。</p>
<h4 id="21-为什么wait和notify方法要在同步块中调用？"><a href="#21-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="21) 为什么wait和notify方法要在同步块中调用？"></a>21) 为什么wait和notify方法要在同步块中调用？</h4><p>主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。还有一个原因是为了避免wait和notify之间产生竞态条件。</p>
<h4 id="22-为什么你应该在循环中检查等待条件"><a href="#22-为什么你应该在循环中检查等待条件" class="headerlink" title="22) 为什么你应该在循环中检查等待条件?"></a>22) 为什么你应该在循环中检查等待条件?</h4><p>处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来 时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方 法效果更好的原因，你可以在<a href="http://res.importnew.com/eclipse" target="_blank" rel="noopener">Eclipse</a>中创建模板调用wait和notify试一试。如果你想了解更多关于这个问题的内容，我推荐你阅读《<a href="http://www.amazon.com/gp/product/B000WJOUPA/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=B000WJOUPA&linkCode=as2&tag=job0ae-20" target="_blank" rel="noopener">Effective Java</a>》这本书中的线程和同步章节。</p>
<h4 id="23-Java中的同步集合与并发集合有什么区别？"><a href="#23-Java中的同步集合与并发集合有什么区别？" class="headerlink" title="23) Java中的同步集合与并发集合有什么区别？"></a>23) Java中的同步集合与并发集合有什么区别？</h4><p>同步集合与并发集合都为多线程和并发提供了合适的线程安全的集合，不过并发集合的可扩展性更高。在Java1.5之前程序员们只有同步集合来用且在 多线程并发的时候会导致争用，阻碍了系统的扩展性。Java5介绍了并发集合像ConcurrentHashMap，不仅提供线程安全还用锁分离和内部分 区等现代技术提高了可扩展性。</p>
<h4 id="24）-Java中堆和栈有什么不同？"><a href="#24）-Java中堆和栈有什么不同？" class="headerlink" title="24） Java中堆和栈有什么不同？"></a>24） Java中堆和栈有什么不同？</h4><p>为什么把这个问题归类在多线程和并发面试题里？因为栈是一块和线程紧密相关的内存区域。每个线程都有自己的栈内存，用于存储本地变量，方法参数和栈 调用，一个线程中存储的变量对其它线程是不可见的。而堆是所有线程共享的一片公用内存区域。对象都在堆里创建，为了提升效率线程会从堆中弄一个缓存到自己 的栈，如果多个线程使用该变量就可能引发问题，这时volatile 变量就可以发挥作用了，它要求线程从主存中读取变量的值。</p>
<h4 id="25）-什么是线程池？-为什么要使用它？"><a href="#25）-什么是线程池？-为什么要使用它？" class="headerlink" title="25） 什么是线程池？ 为什么要使用它？"></a>25） 什么是线程池？ 为什么要使用它？</h4><p>创建线程要花费昂贵的资源和时间，如果任务来了才创建线程那么响应时间会变长，而且一个进程能创建的线程数有限。为了避免这些问题，在程序启动的时 候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程。从JDK1.5开始，Java API提供了Executor框架让你可以创建不同的线程池。比如单线程池，每次处理一个任务；数目固定的线程池或者是缓存线程池（一个适合很多生存期短 的任务的程序的可扩展线程池）。</p>
<h4 id="26）-如何写代码来解决生产者消费者问题？"><a href="#26）-如何写代码来解决生产者消费者问题？" class="headerlink" title="26） 如何写代码来解决生产者消费者问题？"></a>26） 如何写代码来解决生产者消费者问题？</h4><p>在现实中你解决的许多线程问题都属于生产者消费者模型，就是一个线程生产任务供其它线程进行消费，你必须知道怎么进行线程间通信来解决这个问题。比 较低级的办法是用wait和notify来解决这个问题，比较赞的办法是用Semaphore 或者 BlockingQueue来实现生产者消费者模型，<a href="http://javarevisited.blogspot.sg/2012/02/producer-consumer-design-pattern-with.html" target="_blank" rel="noopener">这篇教程</a>有实现它。</p>
<h4 id="27）-如何避免死锁？"><a href="#27）-如何避免死锁？" class="headerlink" title="27） 如何避免死锁？"></a>27） 如何避免死锁？</h4><p><a href="http://www.importnew.com/12773.html/deadlock-in-java" target="_blank" rel="noopener"><img src="/" class="lazyload" data-src="http://www.jcodecraeer.com/uploads/20150206/1423152463136397.jpg"  alt="deadlock in Java"></a><br>Java多线程中的死锁<br>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。这是一个严重的问题，因为死锁会让你的程序挂起无法完成任务，死锁的发生必须满足以下四个条件：</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用。</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<p>避免死锁最简单的方法就是阻止循环等待条件，将系统中所有的资源设置标志位、排序，规定所有的进程申请资源必须以一定的顺序（升序或降序）做操作来避免死锁。</p>
<h4 id="28-Java中活锁和死锁有什么区别？"><a href="#28-Java中活锁和死锁有什么区别？" class="headerlink" title="28) Java中活锁和死锁有什么区别？"></a>28) Java中活锁和死锁有什么区别？</h4><p>这是上题的扩展，活锁和死锁类似，不同之处在于处于活锁的线程或进程的状态是不断改变的，活锁可以认为是一种特殊的饥饿。一个现实的活锁例子是两个 人在狭小的走廊碰到，两个人都试着避让对方好让彼此通过，但是因为避让的方向都一样导致最后谁都不能通过走廊。简单的说就是，活锁和死锁的主要区别是前者 进程的状态可以改变但是却不能继续执行。</p>
<h4 id="29）-怎么检测一个线程是否拥有锁？"><a href="#29）-怎么检测一个线程是否拥有锁？" class="headerlink" title="29） 怎么检测一个线程是否拥有锁？"></a>29） 怎么检测一个线程是否拥有锁？</h4><p>我一直不知道我们竟然可以检测一个线程是否拥有锁，直到我参加了一次电话面试。在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p>
<h4 id="30-你如何在Java中获取线程堆栈？"><a href="#30-你如何在Java中获取线程堆栈？" class="headerlink" title="30) 你如何在Java中获取线程堆栈？"></a>30) 你如何在Java中获取线程堆栈？</h4><p>对于不同的操作系统，有多种方法来获得Java进程的线程堆栈。当你获取线程堆栈时，JVM会把所有线程的状态存到日志文件或者输出到控制台。在 Windows你可以使用Ctrl + Break组合键来获取线程堆栈，Linux下用kill -3命令。你也可以用jstack这个工具来获取，它对线程id进行操作，你可以用jps这个工具找到id。</p>
<h4 id="31-JVM中哪个参数是用来控制线程的栈堆栈小的"><a href="#31-JVM中哪个参数是用来控制线程的栈堆栈小的" class="headerlink" title="31) JVM中哪个参数是用来控制线程的栈堆栈小的"></a>31) JVM中哪个参数是用来控制线程的栈堆栈小的</h4><p>这个问题很简单， -Xss参数用来控制线程的堆栈大小。</p>
<h4 id="32）-Java中synchronized-和-ReentrantLock-有什么不同？"><a href="#32）-Java中synchronized-和-ReentrantLock-有什么不同？" class="headerlink" title="32） Java中synchronized 和 ReentrantLock 有什么不同？"></a>32） Java中synchronized 和 ReentrantLock 有什么不同？</h4><p>Java在过去很长一段时间只能通过synchronized关键字来实现互斥，它有一些缺点。比如你不能扩展锁之外的方法或者块边界，尝试获取锁 时不能中途取消等。Java 5 通过Lock接口提供了更复杂的控制来解决这些问题。 ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义且它还具有可扩展性。</p>
<h4 id="33）-有三个线程T1，T2，T3，怎么确保它们按顺序执行？"><a href="#33）-有三个线程T1，T2，T3，怎么确保它们按顺序执行？" class="headerlink" title="33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？"></a>33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</h4><p>在多线程中有多种方法让线程按特定顺序执行，你可以用线程类的join()方法在一个线程中启动另一个线程，另外一个线程完成该线程继续执行。为了确保三个线程的顺序你应该先启动最后一个(T3调用T2，T2调用T1)，这样T1就会先完成而T3最后完成。</p>
<h4 id="34-Thread类中的yield方法有什么作用？"><a href="#34-Thread类中的yield方法有什么作用？" class="headerlink" title="34) Thread类中的yield方法有什么作用？"></a>34) Thread类中的yield方法有什么作用？</h4><p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<h4 id="35）-Java中ConcurrentHashMap的并发度是什么？"><a href="#35）-Java中ConcurrentHashMap的并发度是什么？" class="headerlink" title="35） Java中ConcurrentHashMap的并发度是什么？"></a>35） Java中ConcurrentHashMap的并发度是什么？</h4><p>ConcurrentHashMap把实际map划分成若干部分来实现它的可扩展性和线程安全。这种划分是使用并发度获得的，它是 ConcurrentHashMap类构造函数的一个可选参数，默认值为16，这样在多线程情况下就能避免争用。</p>
<h4 id="36）-Java中Semaphore是什么？"><a href="#36）-Java中Semaphore是什么？" class="headerlink" title="36） Java中Semaphore是什么？"></a>36） Java中Semaphore是什么？</h4><p>Java中的Semaphore是一种新的同步类，它是一个计数信号。从概念上讲，从概念上讲，信号量维护了一个许可集合。如有必要，在许可可用前 会阻塞每一个 acquire()，然后再获取该许可。每个 release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采 取相应的行动。信号量常常用于多线程的代码中，比如数据库连接池。</p>
<h4 id="37）如果你提交任务时，线程池队列已满。会时发会生什么？"><a href="#37）如果你提交任务时，线程池队列已满。会时发会生什么？" class="headerlink" title="37）如果你提交任务时，线程池队列已满。会时发会生什么？"></a>37）如果你提交任务时，线程池队列已满。会时发会生什么？</h4><p>这个问题问得很狡猾，许多程序员会认为该任务会阻塞直到线程池队列有空位。事实上如果一个任务不能被调度执行那么ThreadPoolExecutor’s submit()方法将会抛出一个RejectedExecutionException异常。</p>
<h4 id="38-Java线程池中submit-和-execute-方法有什么区别？"><a href="#38-Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="38) Java线程池中submit() 和 execute()方法有什么区别？"></a>38) Java线程池中submit() 和 execute()方法有什么区别？</h4><p>两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中, 而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口，其它线 程池类像ThreadPoolExecutor和ScheduledThreadPoolExecutor都有这些方法。</p>
<h4 id="39-什么是阻塞式方法？"><a href="#39-什么是阻塞式方法？" class="headerlink" title="39) 什么是阻塞式方法？"></a>39) 什么是阻塞式方法？</h4><p>阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket的accept()方法就是一直等待客户端连接。这里的阻塞是 指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。</p>
<h4 id="40-Swing是线程安全的吗？-为什么？"><a href="#40-Swing是线程安全的吗？-为什么？" class="headerlink" title="40) Swing是线程安全的吗？ 为什么？"></a>40) Swing是线程安全的吗？ 为什么？</h4><p>你可以很肯定的给出回答，Swing不是线程安全的，但是你应该解释这么回答的原因即便面试官没有问你为什么。当我们说swing不是线程安全的常 常提到它的组件，这些组件不能在多线程中进行修改，所有对GUI组件的更新都要在AWT线程中完成，而Swing提供了同步和异步两种回调方法来进行更 新。</p>
<h4 id="41）-Java中invokeAndWait-和-invokeLater有什么区别？"><a href="#41）-Java中invokeAndWait-和-invokeLater有什么区别？" class="headerlink" title="41） Java中invokeAndWait 和 invokeLater有什么区别？"></a>41） Java中invokeAndWait 和 invokeLater有什么区别？</h4><p>这两个方法是Swing API 提供给Java开发者用来从当前线程而不是事件派发线程更新GUI组件用的。InvokeAndWait()同步更新GUI组件，比如一个进度条，一旦进 度更新了，进度条也要做出相应改变。如果进度被多个线程跟踪，那么就调用invokeAndWait()方法请求事件派发线程对组件进行相应更新。而 invokeLater()方法是异步调用更新组件的。</p>
<h4 id="42-Swing-API中那些方法是线程安全的？"><a href="#42-Swing-API中那些方法是线程安全的？" class="headerlink" title="42) Swing API中那些方法是线程安全的？"></a>42) Swing API中那些方法是线程安全的？</h4><p>这个问题又提到了swing和线程安全，虽然组件不是线程安全的但是有一些方法是可以被多线程安全调用的，比如repaint(), revalidate()。 JTextComponent的setText()方法和JTextArea的insert() 和 append() 方法也是线程安全的。</p>
<h4 id="43-如何在Java中创建Immutable对象？"><a href="#43-如何在Java中创建Immutable对象？" class="headerlink" title="43) 如何在Java中创建Immutable对象？"></a>43) 如何在Java中创建Immutable对象？</h4><p>这个问题看起来和多线程没什么关系， 但不变性有助于简化已经很复杂的并发程序。Immutable对象可以在没有同步的情况下共享，降低了对该对象进行并发访问时的同步化开销。可是Java 没有@Immutable这个注解符，要创建不可变类，要实现下面几个步骤：通过构造方法初始化所有成员、对变量不要提供setter方法、将所有的成员 声明为私有的，这样就不允许直接访问这些成员、在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝。我的文章<a href="http://javarevisited.blogspot.com/2013/03/how-to-create-immutable-class-object-java-example-tutorial.html" target="_blank" rel="noopener">how to make an object Immutable in Java</a>有详细的教程，看完你可以充满自信。</p>
<h4 id="44）-Java中的ReadWriteLock是什么？"><a href="#44）-Java中的ReadWriteLock是什么？" class="headerlink" title="44） Java中的ReadWriteLock是什么？"></a>44） Java中的ReadWriteLock是什么？</h4><p>一般而言，读写锁是用来提升并发程序性能的锁分离技术的成果。Java中的ReadWriteLock是Java 5 中新增的一个接口，一个ReadWriteLock维护一对关联的锁，一个用于只读操作一个用于写。在没有写线程的情况下一个读锁可能会同时被多个读线程 持有。写锁是独占的，你可以使用JDK中的ReentrantReadWriteLock来实现这个规则，它最多支持65535个写锁和65535个读 锁。</p>
<h4 id="45-多线程中的忙循环是什么"><a href="#45-多线程中的忙循环是什么" class="headerlink" title="45) 多线程中的忙循环是什么?"></a>45) 多线程中的忙循环是什么?</h4><p>忙循环就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓存，在多核系统中，一个等待线程醒来的时候可 能会在另一个内核运行，这样会重建缓存。为了避免重建缓存和减少等待重建的时间就可以使用它了。</p>
<h4 id="46）volatile-变量和-atomic-变量有什么不同？"><a href="#46）volatile-变量和-atomic-变量有什么不同？" class="headerlink" title="46）volatile 变量和 atomic 变量有什么不同？"></a>46）volatile 变量和 atomic 变量有什么不同？</h4><p>这是个有趣的问题。首先，volatile 变量和 atomic 变量看起来很像，但功能却不一样。Volatile变量可以确保先行关系，即写操作会发生在后续的读操作之前, 但它并不能保证原子性。例如用volatile修饰count变量那么 count++ 操作就不是原子性的。而AtomicInteger类提供的atomic方法可以让这种操作具有原子性如getAndIncrement()方法会原子性 的进行增量操作把当前值加一，其它数据类型和引用变量也可以进行相似操作。</p>
<h4 id="47-如果同步块内的线程抛出异常会发生什么？"><a href="#47-如果同步块内的线程抛出异常会发生什么？" class="headerlink" title="47) 如果同步块内的线程抛出异常会发生什么？"></a>47) 如果同步块内的线程抛出异常会发生什么？</h4><p>这个问题坑了很多Java程序员，若你能想到锁是否释放这条线索来回答还有点希望答对。无论你的同步块是正常还是异常退出的，里面的线程都会释放锁，所以对比锁接口我更喜欢同步块，因为它不用我花费精力去释放锁，该功能可以在<a href="http://javarevisited.blogspot.com/2012/11/difference-between-final-finally-and-finalize-java.html" target="_blank" rel="noopener">finally block</a>里释放锁实现。</p>
<h4 id="48）-单例模式的双检锁是什么？"><a href="#48）-单例模式的双检锁是什么？" class="headerlink" title="48） 单例模式的双检锁是什么？"></a>48） 单例模式的双检锁是什么？</h4><p>这个问题在Java面试中经常被问到，但是面试官对回答此问题的满意度仅为50%。一半的人写不出双检锁还有一半的人说不出它的隐患和 Java1.5是如何对它修正的。它其实是一个用来创建线程安全的单例的老方法，当单例实例第一次被创建时它试图用单个锁进行性能优化，但是由于太过于复 杂在JDK1.4中它是失败的，我个人也不喜欢它。无论如何，即便你也不喜欢它但是还是要了解一下，因为它经常被问到。</p>
<h4 id="49）-如何在Java中创建线程安全的Singleton？"><a href="#49）-如何在Java中创建线程安全的Singleton？" class="headerlink" title="49） 如何在Java中创建线程安全的Singleton？"></a>49） 如何在Java中创建线程安全的Singleton？</h4><p>这是上面那个问题的后续，如果你不喜欢双检锁而面试官问了创建Singleton类的替代方法，你可以利用JVM的类加载和静态变量初始化特征来创建Singleton实例，或者是利用枚举类型来创建Singleton，我很喜欢用这种方法。</p>
<h4 id="50-写出3条你遵循的多线程最佳实践"><a href="#50-写出3条你遵循的多线程最佳实践" class="headerlink" title="50) 写出3条你遵循的多线程最佳实践"></a>50) 写出3条你遵循的多线程最佳实践</h4><p>这种问题我最喜欢了，我相信你在写并发代码来提升性能的时候也会遵循某些最佳实践。以下三条最佳实践我觉得大多数Java程序员都应该遵循：</p>
<ul>
<li>给你的线程起个有意义的名字。<br>这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</li>
<li>避免锁定和缩小同步的范围<br>锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</li>
<li>多用同步类少用wait 和 notify<br>首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断 优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li>
<li>多用并发集合少用同步集合<br>这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。如果下一次你需要用到map，你应该首先想到用ConcurrentHashMap。</li>
</ul>
<h4 id="51-如何强制启动一个线程？"><a href="#51-如何强制启动一个线程？" class="headerlink" title="51) 如何强制启动一个线程？"></a>51) 如何强制启动一个线程？</h4><p>这个问题就像是如何强制进行Java垃圾回收，目前还没有觉得方法，虽然你可以使用System.gc()来进行垃圾回收，但是不保证能成功。在Java里面没有办法强制启动一个线程，它是被线程调度器控制着且Java没有公布相关的API。</p>
<h4 id="52-Java中的fork-join框架是什么？"><a href="#52-Java中的fork-join框架是什么？" class="headerlink" title="52) Java中的fork join框架是什么？"></a>52) Java中的fork join框架是什么？</h4><p>fork join框架是JDK7中出现的一款高效的工具，Java开发人员可以通过它充分利用现代服务器上的多处理器。它是专门为了那些可以递归划分成许多子模块 设计的，目的是将所有可用的处理能力用来提升程序的性能。fork join框架一个巨大的优势是它使用了工作窃取算法，可以完成更多任务的工作线程可以从其它线程中窃取任务来执行。</p>
<h4 id="53）-Java多线程中调用wait-和-sleep-方法有什么不同？"><a href="#53）-Java多线程中调用wait-和-sleep-方法有什么不同？" class="headerlink" title="53） Java多线程中调用wait() 和 sleep()方法有什么不同？"></a>53） Java多线程中调用wait() 和 sleep()方法有什么不同？</h4><p>Java程序中wait 和 sleep都会造成某种形式的暂停，它们可以满足不同的需要。wait()方法用于线程间通信，如果等待条件为真且其它线程被唤醒时它会释放锁，而 sleep()方法仅仅释放CPU资源或者让当前线程停止执行一段时间，但不会释放锁。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/04/21/java%E5%B9%B6%E5%8F%91/">http://yoursite.com/2020/04/21/java%E5%B9%B6%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="/img/cat.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/25/%E7%AE%97%E6%B3%95-java%E5%AE%9E%E7%8E%B0/"><img class="prev_cover lazyload" data-src="/img/cat.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">算法 java,go实现</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/21/java%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/"><img class="next_cover lazyload" data-src="/img/cat.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">java图像编程</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/21/java图形编程/" title="java图像编程"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-21</div><div class="relatedPosts_title">java图像编程</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/25/算法-java实现/" title="算法 java,go实现"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-25</div><div class="relatedPosts_title">算法 java,go实现</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/28/java-规范/" title="java 规范"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-28</div><div class="relatedPosts_title">java 规范</div></div></a></div><div class="relatedPosts_item"><a href="/2020/04/28/java-学习笔记二/" title="java 学习笔记二"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-28</div><div class="relatedPosts_title">java 学习笔记二</div></div></a></div><div class="relatedPosts_item"><a href="/2020/09/11/java-web技术/" title="java web技术"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-09-11</div><div class="relatedPosts_title">java web技术</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><script id="utterances_comment" src="https://utteranc.es/client.js" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script><script>var themeNow = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
document.getElementById('utterances_comment').setAttribute('theme',themeNow)

function utterancesTheme () {
var theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
const message = {
  type: 'set-theme',
  theme: theme
};
const iframe = document.querySelector('.utterances-frame');
iframe.contentWindow.postMessage(message, 'https://utteranc.es');
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Lin</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script></body></html>