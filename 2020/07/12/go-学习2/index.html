<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>go 学习2 | LIN is keeping learning</title><meta name="description" content="go 学习2"><meta name="keywords" content="Go"><meta name="author" content="Lin"><meta name="copyright" content="Lin"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="go 学习2"><meta name="twitter:description" content="go 学习2"><meta name="twitter:image" content="http://yoursite.com/img/cat.jpg"><meta property="og:type" content="article"><meta property="og:title" content="go 学习2"><meta property="og:url" content="http://yoursite.com/2020/07/12/go-%E5%AD%A6%E4%B9%A02/"><meta property="og:site_name" content="LIN is keeping learning"><meta property="og:description" content="go 学习2"><meta property="og:image" content="http://yoursite.com/img/cat.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/07/12/go-%E5%AD%A6%E4%B9%A02/"><link rel="prev" title="java JVM" href="http://yoursite.com/2020/07/13/java-JVM/"><link rel="next" title="Go-Web" href="http://yoursite.com/2020/07/08/Go-Web/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://linbener.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"爱国,敬业,友善,诚实,自由,平等,和谐","fontSize":"12px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/tou.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">Articles</div><div class="length_num">28</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">Tags</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">Categories</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#Context"><span class="toc-number">1.</span> <span class="toc-text">Context</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go-unsafe-包之内存布局"><span class="toc-number">2.</span> <span class="toc-text">Go unsafe 包之内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Go语言经典库使用分析"><span class="toc-number">3.</span> <span class="toc-text">Go语言经典库使用分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#goquery-库-解析dom"><span class="toc-number">3.1.</span> <span class="toc-text">goquery 库 解析dom</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#httprouter"><span class="toc-number">3.2.</span> <span class="toc-text">httprouter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#go-spew"><span class="toc-number">3.3.</span> <span class="toc-text">go-spew</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Web框架推荐的库"><span class="toc-number">3.4.</span> <span class="toc-text">Web框架推荐的库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能优化"><span class="toc-number">4.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#range-和-for-对比"><span class="toc-number">4.1.</span> <span class="toc-text">range 和 for 对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串高效拼接"><span class="toc-number">4.2.</span> <span class="toc-text">字符串高效拼接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#高效生成随机字符串"><span class="toc-number">4.3.</span> <span class="toc-text">高效生成随机字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字符串转换成字符数组"><span class="toc-number">4.4.</span> <span class="toc-text">字符串转换成字符数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#切片和数组的高效转换"><span class="toc-number">4.5.</span> <span class="toc-text">切片和数组的高效转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理方案"><span class="toc-number"></span> <span class="toc-text">错误处理方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Error-Wrapping"><span class="toc-number">0.1.</span> <span class="toc-text">Error Wrapping</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go语言的类型断言"><span class="toc-number"></span> <span class="toc-text">Go语言的类型断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go语言编写可维护代码经验"><span class="toc-number"></span> <span class="toc-text">Go语言编写可维护代码经验</span></a></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/cat.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">LIN is keeping learning</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">go 学习2</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="Created 2020-07-12 22:28:14"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2020-07-12</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="Updated 2020-08-10 21:29:31"><i class="fa fa-history" aria-hidden="true"></i> Updated 2020-08-10</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>Post View:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>链接学习：飞雪无情 <a href="https://www.flysnow.org/" target="_blank" rel="noopener">https://www.flysnow.org/</a></p>
<p>控制多个goroute的方式</p>
<ol>
<li>WaitGroup</li>
<li>chan 通知</li>
<li>Context</li>
</ol>
<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p>Context控制多个协程</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">"【监控1】"</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">"【监控2】"</span>)</span><br><span class="line">	<span class="keyword">go</span> watch(ctx,<span class="string">"【监控3】"</span>)</span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">	cancel()</span><br><span class="line">	<span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">			fmt.Println(name,<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			fmt.Println(name,<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">			time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动了3个监控goroutine进行不断的监控，每一个都使用了Context进行跟踪，当我们使用<code>cancel</code>函数通知取消时，这3个goroutine都会被结束。这就是Context的控制能力，它就像一个控制器一样，按下开关后，所有基于这个Context或者衍生的子Context都会收到通知，这时就可以进行清理操作了，最终释放goroutine，这就优雅的解决了goroutine启动后不可控的问题。</p>
<p>Context接口有四个方法</p>
<p>Deadline Done Err Value</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	Err() error</span><br><span class="line"></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Deadline</code>方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context会自动发起取消请求；第二个返回值ok==false时表示没有设置截止时间，如果需要取消的话，需要调用取消函数进行取消。</p>
<p><code>Done</code>方法返回一个只读的chan，类型为<code>struct{}</code>，我们在goroutine中，如果该方法返回的chan可以读取，则意味着parent context已经发起了取消请求，我们通过<code>Done</code>方法收到这个信号后，就应该做清理操作，然后退出goroutine，释放资源。</p>
<p>Go内置了两个实现的Context</p>
<p>一个是<code>Background</code>，主要用于main函数、初始化以及测试代码中，作为Context这个树结构的最顶层的Context，也就是根Context。</p>
<p>一个是<code>TODO</code>,它目前还不知道具体的使用场景，如果我们不知道该使用什么Context的时候，可以使用这个。</p>
<p>他们两个本质上都是<code>emptyCtx</code>结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的Context。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>衍生更多的子Context，这就要靠<strong>context包</strong>为我们提供的<code>With</code>系列的函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure>



<p><strong>context的其他用途，比如往Http.Request里添加附加值。</strong></p>
<h4 id="Go-unsafe-包之内存布局"><a href="#Go-unsafe-包之内存布局" class="headerlink" title="Go unsafe 包之内存布局"></a>Go unsafe 包之内存布局</h4><p>这个包是不安全的，尽可能不用他，这个包可以绕过Go的内存安全机制，直接对内存进行读写，所以有时候因为性能的需要，会冒一些风险使用该包，对内存进行操作</p>
<p><strong>Sizeof函数</strong></p>
<p>返回一个类型所占用的内存大小，这个大小只有类型有关，和类型对应的变量存储的内容大小无关</p>
<p><strong>Alignof函数</strong></p>
<p>返回一个类型的对齐值，也可以叫做对齐系数或者对齐倍数。对齐值是一个和内存对齐有关的值，合理的内存对齐可以提高内存读写的性能</p>
<p><strong>Offsetof函数</strong></p>
<p><code>Offsetof</code>函数只适用于struct结构体中的字段相对于结构体的内存位置偏移量。结构体的第一个字段的偏移量都是0.</p>
<p>对齐影响struct占据内存的大小，同一个struct内不同的字段排序方式，通过Sizeof函数测量的内存大小不同，<strong>所以有时候合理的字段顺序可以减少内存的开销</strong>。</p>
<p>内存对齐会影响struct的内存占用大小</p>
<p>内存对齐规则：</p>
<ol>
<li>对于具体类型来说，<strong>对齐值=min(编译器默认对齐值，类型大小Sizeof长度)</strong>。</li>
<li>struct在每个字段都内存对齐之后，其本身也要进行对齐，<strong>对齐值=min(默认对齐值，字段最大类型长度)</strong>。这条也很好理解，struct的所有字段中，最大的那个类型的长度以及默认对齐值之间，取最小的那个。</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u:=<span class="built_in">new</span>(user)</span><br><span class="line">	fmt.Println(*u)</span><br><span class="line"></span><br><span class="line">	pName:=(*<span class="keyword">string</span>)(unsafe.Pointer(u))</span><br><span class="line">	*pName=<span class="string">"张三"</span></span><br><span class="line"></span><br><span class="line">	pAge:=(*<span class="keyword">int</span>)(unsafe.Pointer(<span class="keyword">uintptr</span>(unsafe.Pointer(u))+unsafe.Offsetof(u.age)))</span><br><span class="line">	*pAge = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(*u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个修改<code>user</code>的<code>name</code>值的时候，因为<code>name</code>是第一个字段，所以不用偏移，我们获取<code>user</code>的指针，然后通过<code>unsafe.Pointer</code>转为<code>*string</code>进行赋值操作即可。</p>
<p>第二个修改<code>user</code>的<code>age</code>值的时候，因为<code>age</code>不是第一个字段，所以我们需要内存偏移，内存偏移牵涉到的计算只能通过<code>uintptr</code>，所我们要先把<code>user</code>的指针地址转为<code>uintptr</code>，然后我们再通过<code>unsafe.Offsetof(u.age)</code>获取需要偏移的值，进行地址运算(+)偏移即可。</p>
<p>Go并发 Runner</p>
<p>执行者，它可以在后台执行任何任务，我们可以控制这个执行者，比如强制终止它。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个执行者，可以执行任何任务，但是这些任务是限制完成的，</span></span><br><span class="line"><span class="comment">//该执行者可以通过发送终止信号终止它</span></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">struct</span> &#123;</span><br><span class="line">	tasks []<span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> //要执行的任务</span></span><br><span class="line">	complete <span class="keyword">chan</span> error <span class="comment">//用于通知任务全部完成</span></span><br><span class="line">	timeout &lt;-<span class="keyword">chan</span> time.Time <span class="comment">//这些任务在多久内完成</span></span><br><span class="line">	interrupt <span class="keyword">chan</span> os.Signal <span class="comment">//可以控制强制终止的信号</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Go并发 pool资源池</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个安全的资源池，被管理的资源必须都实现io.Close接口</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	m sync.Mutex</span><br><span class="line">	res <span class="keyword">chan</span> io.Closer</span><br><span class="line">	factory <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.Closer,error)</span></span></span><br><span class="line">	closed <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Go语言经典库使用分析"><a href="#Go语言经典库使用分析" class="headerlink" title="Go语言经典库使用分析"></a>Go语言经典库使用分析</h4><p>Gorilla Handlers 中间件库</p>
<p>LoggingHandler这个函数，它接收一个http.Handler对象，返回的也是一个Handler对象，它内在的逻辑是对原本的Handler对象进行一次包装，这就是中间件。它的内在逻辑是在页面输出日记信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.Handle(<span class="string">"/"</span>,useLoggingHandler(handler()))</span><br><span class="line">	http.ListenAndServe(<span class="string">":1234"</span>,<span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handler</span><span class="params">()</span> <span class="title">http</span>.<span class="title">Handler</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(myHandler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myHandler</span><span class="params">(rw http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	rw.WriteHeader(http.StatusOK)</span><br><span class="line">	io.WriteString(rw,<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">useLoggingHandler</span><span class="params">(next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> handlers.LoggingHandler(os.Stdout,next)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CombinedLoggingHandler</p>
<p>CompressHandler</p>
<p>ContentTypeHandler</p>
<p>CanonicalHost 重定向的中间件</p>
<p><strong>Negroni</strong> 中间件</p>
<p>一个非常经典的库，非常小，但是功能强大，因为他定义了中间件的框架和风格，让我们可以基于它开发出我们自己的中间件，并且可以集成到Negroni中</p>
<p>Negroni还兼容原生的http.Handler,你完全可以把自己的http.Handler加入到Negroni的中间件链中</p>
<p><strong>高性能，高并发的json库</strong></p>
<p>json-iterator 和 easyjson</p>
<p><strong>同时使用官方的json解析器和json-iterator解析器，解决办法就是条件编译</strong>。</p>
<p><strong>Go语言为我们提供了基于tags的编译约束来解决这个问题</strong></p>
<p>命令行 -tags=</p>
<p>文件前面加上// +build jsoniter</p>
<p>json/json.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build !jsoniter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Use [encoding/json] package"</span>)</span><br><span class="line">	<span class="keyword">return</span> json.MarshalIndent(v,prefix,indent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><em>json/jsoniter.go</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// +build jsoniter</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/json-iterator/go"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	json = jsoniter.ConfigCompatibleWithStandardLibrary</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MarshalIndent</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, prefix, indent <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"Use [jsoniter] package"</span>)</span><br><span class="line">	<span class="keyword">return</span> json.MarshalIndent(v,prefix,indent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目录结构</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">json</span><br><span class="line">├── json.go</span><br><span class="line">└── jsoniter.go</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"flysnow.org/hello/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	u:=user&#123;<span class="string">"飞雪无情"</span>,<span class="string">"http://www.flysnow.org/"</span>,<span class="string">"flysnow_org"</span>&#125;</span><br><span class="line">	b,err:=json.MarshalIndent(u,<span class="string">""</span>,<span class="string">"  "</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="keyword">string</span>(b))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span></span><br><span class="line">	Blog <span class="keyword">string</span></span><br><span class="line">	Wechat <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>命令：</p>
<p>go run main.go</p>
<p>go run -tags=jsoniter main.go</p>
<p>而<code>+build</code>可以理解为条件编译tags的声明关键字，后面跟着tags的条件。</p>
<h5 id="goquery-库-解析dom"><a href="#goquery-库-解析dom" class="headerlink" title="goquery 库 解析dom"></a>goquery 库 解析dom</h5><p>goquery类似jquery，它是jquery的go版本实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	html := <span class="string">`&lt;body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">				&lt;div id="div1"&gt;DIV1&lt;/div&gt;</span></span><br><span class="line"><span class="string">				&lt;div class="name"&gt;DIV2&lt;/div&gt;</span></span><br><span class="line"><span class="string">				&lt;span&gt;SPAN&lt;/span&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			&lt;/body&gt;</span></span><br><span class="line"><span class="string">			`</span></span><br><span class="line"></span><br><span class="line">	dom,err:=goquery.NewDocumentFromReader(strings.NewReader(html))</span><br><span class="line">	<span class="keyword">if</span> err!=<span class="literal">nil</span>&#123;</span><br><span class="line">		log.Fatalln(err)</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//基于元素标签</span></span><br><span class="line">    dom.Find(<span class="string">"div"</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, selection *goquery.Selection)</span></span> &#123;</span><br><span class="line">		fmt.Println(selection.Text())</span><br><span class="line">	&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//基于ID选择器    </span></span><br><span class="line">	dom.Find(<span class="string">"#div1"</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, selection *goquery.Selection)</span></span> &#123;</span><br><span class="line">		fmt.Println(selection.Text())</span><br><span class="line">	&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//基于 .class选择器</span></span><br><span class="line">    	dom.Find(<span class="string">".name"</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, selection *goquery.Selection)</span></span> &#123;</span><br><span class="line">		fmt.Println(selection.Text())</span><br><span class="line">	&#125;)</span><br><span class="line"><span class="comment">//基于属性选择器    </span></span><br><span class="line">    dom.Find(<span class="string">"div[class]"</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, selection *goquery.Selection)</span></span> &#123;</span><br><span class="line">		fmt.Println(selection.Text())</span><br><span class="line">	&#125;)</span><br><span class="line">    </span><br><span class="line"><span class="comment">//dom.Find("div[class=name]")</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//parent&gt;child选择器，符合child这个条件的最直接（一级）的子元素</span></span><br><span class="line">    dom.Find(<span class="string">"body&gt;div"</span>).Each(<span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>, selection *goquery.Selection)</span></span> &#123;</span><br><span class="line">		fmt.Println(selection.Text())</span><br><span class="line">	&#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外还有prev+next相邻选择器 ，prev~next选择器</p>
<p><strong>内容过滤器</strong> :first-child过滤器</p>
<p>选择器或(|)运算，同时筛选出<code>div</code>,<code>span</code>等元素怎么办？这时候可以采用多个选择器进行组合使用，并且以逗号(,)分割，<code>Find(&quot;selector1, selector2, selectorN&quot;)</code>表示，只要满足其中一个选择器就可以被筛选出来，也就是选择器的或(|)运算操作。</p>
<p>基准测试示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TwoSum1</span><span class="params">(nums []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	n:=<span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i,v:=<span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">for</span> j:=i+<span class="number">1</span>;j&lt;n;j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> v+nums[j] == target &#123;</span><br><span class="line">				<span class="keyword">return</span> []<span class="keyword">int</span>&#123;i,j&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lib包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkTwoSum1</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;b.N;i++&#123;</span><br><span class="line">		TwoSum1([]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,<span class="number">9</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//lib go test -bench=. -benchmem -run=none</span></span><br></pre></td></tr></table></figure>



<p>现在我们可以总结下<code>net/http</code>包对HTTP请求的处理。</p>
<p>HTTP请求-&gt;ServeHTTP函数-&gt;ServeMux的Handler方法-&gt;Index函数</p>
<p>我们自己在使用内置的<code>net/http</code>的默认路径处理HTTP请求的时候，会发现很多不足，比如：</p>
<ol>
<li>不能单独的对请求方法(POST,GET等)注册特定的处理函数</li>
<li>不支持Path变量参数</li>
<li>不能自动对Path进行校准</li>
<li>性能一般</li>
<li>扩展性不足</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span> &#123;</span><br><span class="line">	handler := sh.srv.Handler</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这个判断成立，因为我们传递的是nil</span></span><br><span class="line">	<span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">		handler = DefaultServeMux</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//省略了一些代码</span></span><br><span class="line">	handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的代码分析，我们自己在通过<code>http.ListenAndServe</code>函数启动一个HTTP服务的时候，最后一个<code>handler</code>的值是nil，所以上面的nil判断成立，使用的就是默认的路由<code>DefaultServeMux</code>。</p>
<p>现在我们就知道如何使用自己定义的路由了，那就是给<code>http.ListenAndServe</code>的最后一个参数<code>handler</code>传一个自定义的路由。</p>
<h5 id="httprouter"><a href="#httprouter" class="headerlink" title="httprouter"></a>httprouter</h5><p>httprouter 是一个高性能、可扩展的HTTP路由，上面我们列举的<code>net/http</code>默认路由的不足，都被httprouter 实现。</p>
<p>场景：</p>
<p>使用Golang（Go语言）开发的过程中，会通过经常通过调试的方式查找问题的原因，解决问题，尤其是当遇到一个很棘手的问题的时候，就需要知道一段代码在执行的过程中，其上下文的变量对应的数据，以便进行推测出问题的原因。</p>
<p>对于这类调试，我们用的比较多的一个是断点调试，还有是通过打印日志输出。通过日志打印的话，可能一开始常用的就是<code>fmt.Println</code>输出，简单，边界。如果我们再想看一些更多信息的话，比如行号，可以通过<code>log</code>包。</p>
<h5 id="go-spew"><a href="#go-spew" class="headerlink" title="go-spew"></a>go-spew</h5><p>go-spew可以帮助Golang开发者打印数据的结构，并且以一种比较易读的方式，让开发者，可以看到一个变量的数据结构信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i:=<span class="number">0</span></span><br><span class="line">	s:=<span class="string">"哈哈"</span></span><br><span class="line">	spew.Dump(i,s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(int) 0</span></span><br><span class="line"><span class="comment">//(string) (len=6) "哈哈"</span></span><br></pre></td></tr></table></figure>

<p><strong>Dump,Fdump,Sdump 函数</strong></p>
<p><code>Dump</code>函数，是标准的输出到<code>os.Stdout</code>的，也就是我的控制台标准输出。</p>
<p><code>Fdump</code>函数，允许我们自定义一个输出<code>io.Writer</code>，可以是<code>os.Stdout</code>，也可以是其他<code>*File</code>等,只要实现了<code>io.Writer</code>接口就可以。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Dump</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fdump(&amp;Config, os.Stdout, a...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fdump</span><span class="params">(w io.Writer, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	fdump(&amp;Config, w, a...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Printf, Fprintf,Sprintf 函数</strong></p>
<p>上面的<code>Dump</code>系列函数，虽然可以满足我们的大部分需求，但是<code>spew</code>也为我们提供了定制输出风格的函数，他们和<code>fmt</code>的函数用法非常相似。</p>
<h5 id="Web框架推荐的库"><a href="#Web框架推荐的库" class="headerlink" title="Web框架推荐的库"></a>Web框架推荐的库</h5><p><strong>gin</strong></p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><h5 id="range-和-for-对比"><a href="#range-和-for-对比" class="headerlink" title="range 和 for 对比"></a>range 和 for 对比</h5><p>遍历切片</p>
<p>常规而言使用range遍历切片的效率比for低，这个是因为range中存在复制行为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForSlice</span><span class="params">(s []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">len</span> := <span class="built_in">len</span>(s)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++ &#123;</span><br><span class="line">		_, _ = i, s[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RangeForSlice</span><span class="params">(s []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;  <span class="comment">//s切片的子元素被复制到  v变量 上消耗了时间</span></span><br><span class="line">		_, _ = i, v</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改进版range</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RangeForSlice</span><span class="params">(s []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> s &#123;  <span class="comment">//s切片 用 _ 忽略了复制变量的行为</span></span><br><span class="line">		_, _ = i, s[i]     <span class="comment">//采用s[i]下标的方式更有效率</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="字符串高效拼接"><a href="#字符串高效拼接" class="headerlink" title="字符串高效拼接"></a>字符串高效拼接</h5><p><strong>+号拼接</strong></p>
<p>这种拼接最简单，也最容易被我们使用，因为它是不限编程语言的。</p>
<p><strong>fmt拼接</strong></p>
<p>借助于fmt.Sprint系列函数进行拼接，然后返回字符串</p>
<p><strong>Join拼接</strong></p>
<p>借助于字符串strings.Join函数进行拼接</p>
<p><strong>buffer 拼接</strong></p>
<p>使用的是<code>bytes.Buffer</code>进行的字符串拼接，它是非常灵活的一个结构体，不止可以拼接字符串，还是可以<code>byte</code>,<code>rune</code>等，并且实现了<code>io.Writer</code>接口，写入也非常方便</p>
<p><strong>builder 拼接</strong></p>
<p><code>strings.Builder</code></p>
<p>为了改进buffer拼接的性能，从go 1.10 版本开始，增加了一个builder类型，用于提升字符串拼接的性能。它的使用和buffer几乎一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringPlus</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">	s+=<span class="string">"昵称"</span>+<span class="string">":"</span>+<span class="string">"飞雪无情"</span>+<span class="string">"\n"</span></span><br><span class="line">	<span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringFmt</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprint(<span class="string">"昵称"</span>,<span class="string">":"</span>,<span class="string">"飞雪无情"</span>,<span class="string">"\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringJoin</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	s:=[]<span class="keyword">string</span>&#123;<span class="string">"昵称"</span>,<span class="string">":"</span>,<span class="string">"飞雪无情"</span>,<span class="string">"\n"</span>&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.Join(s,<span class="string">""</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringBuffer</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b bytes.Buffer</span><br><span class="line">	b.WriteString(<span class="string">"昵称"</span>)</span><br><span class="line">	b.WriteString(<span class="string">":"</span>)</span><br><span class="line">	b.WriteString(<span class="string">"飞雪无情"</span>)</span><br><span class="line">	b.WriteString(<span class="string">"\n"</span>)</span><br><span class="line">	<span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringBuilder</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b strings.Builder</span><br><span class="line">	b.WriteString(<span class="string">"昵称"</span>)</span><br><span class="line">	b.WriteString(<span class="string">":"</span>)</span><br><span class="line">	b.WriteString(<span class="string">"飞雪无情"</span>)</span><br><span class="line">	b.WriteString(<span class="string">"\n"</span>)   </span><br><span class="line">	<span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过基准测试：</p>
<p>性能最好的是<code>+</code>号拼接、Join拼接，最慢的是fmt拼接，这里的builder和buffer拼接差不多，并没有发挥出其能力。</p>
<p>考虑：</p>
<p>拼接字符串的数量和拼接字符串的大小</p>
<ol>
<li><code>+</code> 连接适用于短小的、常量字符串（明确的，非变量），因为编译器会给我们优化。</li>
<li><code>Join</code>是比较统一的拼接，不太灵活</li>
<li><code>fmt</code>和<code>buffer</code>基本上不推荐</li>
<li><code>builder</code>从性能和灵活性上，都是上佳的选择。</li>
</ol>
<p>如果有现成的数组、切片那么可以直接使用<code>Join</code>,但是如果没有，并且追求灵活性拼接，还是选择<code>Builder</code></p>
<p><strong>提升<code>Builder</code>的性能</strong></p>
<p>减少内存分配的次数</p>
<p>通过cpuprofile，发现<code>runtime.growslice</code>函数会被频繁的调用</p>
<p>核心手段就是减少<code>runtime.growslice</code>调用，甚至不调用。照着这个思路的话，我们就要提前为<code>b.buf</code>分配好容量<code>cap</code>。幸好<code>Builder</code>为我们提供了扩充容量的方法<code>Grow</code>，我们在进行<code>WriteString</code>之前，先通过<code>Grow</code>方法，扩充好容量即可。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StringBuilder</span><span class="params">(p []<span class="keyword">string</span>,<span class="built_in">cap</span> <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b strings.Builder</span><br><span class="line">	l:=<span class="built_in">len</span>(p)</span><br><span class="line">	b.Grow(<span class="built_in">cap</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;l;i++&#123;</span><br><span class="line">		b.WriteString(p[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="高效生成随机字符串"><a href="#高效生成随机字符串" class="headerlink" title="高效生成随机字符串"></a>高效生成随机字符串</h5><p>常规做法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    rand.Seed(time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> letterRunes = []<span class="keyword">rune</span>(<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandStringRunes</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">rune</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">        b[i] = letterRunes[rand.Intn(<span class="built_in">len</span>(letterRunes))]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Bytes改进</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> letterBytes = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandStringBytes</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> b &#123;</span><br><span class="line">        b[i] = letterBytes[rand.Intn(<span class="built_in">len</span>(letterBytes))]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">string</span>(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们的随机字符串只包含大小写字母，这样的话，我们发现没有必要使用<code>rune</code>类型存储，因为在Golang（Go语言）UTF-8编码下，英文字母和<code>byte</code>字节是一对一的。<code>byte</code>的本质是<code>uint8</code>类型，而<code>rune</code>本质是<code>int32</code>类型。</p>
<p>最终解决方案：</p>
<p><strong>使用unsafe包模拟 strings.Builder</strong></p>
<p><code>strings.Builder</code>的原理其实很简单，是内置了一个<code>[]byte</code>存储字符，最终转换为<code>string</code>的时候为了避免拷贝，使用了<code>unsafe</code>包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b.buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RandStringBytesMaskImprSrcUnsafe</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, n)</span><br><span class="line">    <span class="comment">// A src.Int63() generates 63 random bits, enough for letterIdxMax characters!</span></span><br><span class="line">    <span class="keyword">for</span> i, cache, remain := n<span class="number">-1</span>, src.Int63(), letterIdxMax; i &gt;= <span class="number">0</span>; &#123;</span><br><span class="line">        <span class="keyword">if</span> remain == <span class="number">0</span> &#123;</span><br><span class="line">            cache, remain = src.Int63(), letterIdxMax</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> idx := <span class="keyword">int</span>(cache &amp; letterIdxMask); idx &lt; <span class="built_in">len</span>(letterBytes) &#123;</span><br><span class="line">            b[i] = letterBytes[idx]</span><br><span class="line">            i--</span><br><span class="line">        &#125;</span><br><span class="line">        cache &gt;&gt;= letterIdxBits</span><br><span class="line">        remain--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *(*<span class="keyword">string</span>)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <a href="https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go" target="_blank" rel="noopener">https://stackoverflow.com/questions/22892120/how-to-generate-a-random-string-of-a-fixed-length-in-go</a></p>
<p><a href="https://www.flysnow.org/2019/09/30/how-to-generate-a-random-string-of-a-fixed-length-in-go.html" target="_blank" rel="noopener">https://www.flysnow.org/2019/09/30/how-to-generate-a-random-string-of-a-fixed-length-in-go.html</a></p>
<h5 id="字符串转换成字符数组"><a href="#字符串转换成字符数组" class="headerlink" title="字符串转换成字符数组"></a>字符串转换成字符数组</h5><p>直接转换的效率再高并发下速度不高，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s:&#x3D;&quot;hello,myworld!&quot;</span><br><span class="line">char:&#x3D;[]byte(s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;高明的方式</span><br><span class="line">func str2bytes(s string) []byte &#123;</span><br><span class="line">    x :&#x3D; (*[2]uintptr)(unsafe.Pointer(&amp;s))</span><br><span class="line">    h :&#x3D; [3]uintptr&#123;x[0], x[1], x[1]&#125;</span><br><span class="line">     return *(*[]byte)(unsafe.Pointer(&amp;h))</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func bytes2str(b []byte) string &#123;</span><br><span class="line">    return *(*string)(unsafe.Pointer(&amp;b))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>更高明的方式是使用unsafe,Pointer的方式进行数组和字符串转换</strong></p>
<h5 id="切片和数组的高效转换"><a href="#切片和数组的高效转换" class="headerlink" title="切片和数组的高效转换"></a>切片和数组的高效转换</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func byte2string2(in [16]byte) []byte &#123;</span><br><span class="line">    tmp :&#x3D; make([]byte, 0)</span><br><span class="line">    x :&#x3D; (*[3]uintptr)(unsafe.Pointer(&amp;tmp))</span><br><span class="line">    x[0] &#x3D; uintptr(unsafe.Pointer(&amp;in))</span><br><span class="line">    x[1] &#x3D; 16</span><br><span class="line">    x[2] &#x3D; 16</span><br><span class="line">    return tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="错误处理方案"><a href="#错误处理方案" class="headerlink" title="错误处理方案"></a>错误处理方案</h3><p><code>error</code>其实一个接口，内置的，我们看下它的定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">	Error() <span class="keyword">string</span> <span class="comment">//返回的是字符串，可以返回错误类型</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一般处理，通过<code>New</code>函数，辅助我们创建不同的错误了，这其实就是我们经常用到的<code>errors.New</code>函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *errorString)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>Go语言对错误的设计非常简洁，但是对于我们开发者来说，很明显是不足的，比如我们需要知道出错的更多信息。</p>
<p>如果要解决以上的问题，那么首先我们必须再继续扩充我们的<code>errorString</code>，再增加一些字段来存储更多的信息。比如我们要记录堆栈信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> stack []<span class="keyword">uintptr</span></span><br><span class="line"><span class="keyword">type</span> errorString <span class="keyword">struct</span> &#123;</span><br><span class="line">	s <span class="keyword">string</span></span><br><span class="line">	*stack <span class="comment">//有了存储堆栈信息的stack字段，我们在生成错误的时候，就可以把调用的堆栈信息存储在这个字段里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">callers</span><span class="params">()</span> *<span class="title">stack</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> depth = <span class="number">32</span></span><br><span class="line">	<span class="keyword">var</span> pcs [depth]<span class="keyword">uintptr</span></span><br><span class="line">	n := runtime.Callers(<span class="number">3</span>, pcs[:])</span><br><span class="line">	<span class="keyword">var</span> st stack = pcs[<span class="number">0</span>:n]</span><br><span class="line">	<span class="keyword">return</span> &amp;st</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(text <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;errorString&#123;</span><br><span class="line">		s:   text,</span><br><span class="line">		stack: callers(),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> withMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">	cause error</span><br><span class="line">	msg   <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;withMessage&#123;</span><br><span class="line">		cause: err,</span><br><span class="line">		msg:   message,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>WithMessage</code>函数，对原来的<code>error</code>包装下，就可以生成一个新的带有包装信息的错误了。</p>
<p>以上的代码是 <code>github.com/pkg/errors</code>这个错误处理库的源代码。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(message <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"><span class="comment">//只附加新的信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithMessage</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只附加调用堆栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithStack</span><span class="params">(err error)</span> <span class="title">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//同时附加堆栈和信息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Wrap</span><span class="params">(err error, message <span class="keyword">string</span>)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure>

<p>它的使用非常简单，如果我们要新生成一个错误，可以使用<code>New</code>函数,生成的错误，自带调用堆栈信息。</p>
<p>这个错误处理库为我们提供了<code>Cause</code>函数让我们可以获得最根本的错误原因</p>
<p>Go 1.13发布的功能还有一个值得深入研究的，就是对Error的增强，也是今天我们要分析的 Error Wrapping.</p>
<p>如果我们想给<code>error</code>增加一些附加文本怎么做呢？有两种办法：</p>
<p>第一种：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">newErr:=fmt.Errorf(<span class="string">"数据上传问题: %v"</span>, err)</span><br></pre></td></tr></table></figure>

<p>通过<code>fmt.Errorf</code>函数，基于已经存在的<code>err</code>再生成一个新的<code>newErr</code>，然后附加上我们想添加的文本信息。这种办法比较方便，但是问题也很明显，我们丢失了原来的<code>err</code>，因为它已经被我们的<code>fmt.Errorf</code>函数转成一个新的字符串了</p>
<p>第二种：重新设置一个结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	newErr := MyError&#123;err, <span class="string">"数据上传问题"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">	err error</span><br><span class="line">	msg <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> e.err.Error() + e.msg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Error-Wrapping"><a href="#Error-Wrapping" class="headerlink" title="Error Wrapping"></a>Error Wrapping</h5><p>Error Wrapping，顾名思义，就是为我们提供了，可以一个<code>error</code>嵌套另一个<code>error</code>功能，好处就是我们可以根据嵌套的<code>error</code>序列，生成一个<code>error</code>错误跟踪链，也可以理解为错误堆栈信息，这样可以便于我们跟踪调试，哪些错误引起了什么问题，根本的问题原因在哪里。</p>
<p>因为<code>error</code>可以嵌套，所以每次嵌套的时候，我们都可以提供新的错误信息，并且保留原来的<code>error</code>。现在我们看下如何生成一个嵌套的<code>error</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := errors.New(<span class="string">"原始错误e"</span>)</span><br><span class="line">w := fmt.Errorf(<span class="string">"Wrap了一个错误%w"</span>, e)</span><br></pre></td></tr></table></figure>

<p>Golang并没有提供什么<code>Wrap</code>函数，而是扩展了<code>fmt.Errorf</code>函数，<strong>加了一个<code>%w</code>来生成一个可以Wrapping Error</strong>,通过这种方式，我们可以创建一个个以Wrapping Error。</p>
<p>Error Wrapping的本质就是有一个结构体：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> wrapError <span class="keyword">struct</span> &#123;</span><br><span class="line">	msg <span class="keyword">string</span></span><br><span class="line">	err error</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个和我们的第二种方式是一样的。</span></span><br></pre></td></tr></table></figure>



<p><strong>Is函数</strong></p>
<p>在Go 1.13之前没有wrapping error的时候，我们要判断error是不是同一个error可以使用如下办法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> err == os.ErrExist</span><br></pre></td></tr></table></figure>



<p>但是现在有了wrapping error后这样办法就不完美的，因为你根本不知道返回的这个<code>err</code>是不是一个嵌套的error,嵌套了几层。所以基于这种情况，Golang为我们提供了<code>errors.Is</code>函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Is</span><span class="params">(err, target error)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>如果<code>err</code>和<code>target</code>是同一个，那么返回<code>true</code></li>
<li>如果<code>err</code> 是一个wrap error,<code>target</code>也包含在这个嵌套error链中的话，那么也返回<code>true</code>。</li>
</ol>
<p><strong>As 函数</strong></p>
<p>在Go 1.13之前没有wrapping error的时候，我们要把error转为另外一个error，一般都是使用type assertion 或者 type switch，其实也就是类型断言。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> perr, ok := err.(*os.PathError); ok &#123;</span><br><span class="line">	fmt.Println(perr.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如例子中的这种方式，但是现在给你返回的err可能是已经被嵌套了，甚至好几层了，这种方式就不能用了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> perr *os.PathError</span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;perr) &#123;</span><br><span class="line">	fmt.Println(perr.Path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">As</span><span class="params">(err error, target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span></span><br></pre></td></tr></table></figure>





<h3 id="Go语言的类型断言"><a href="#Go语言的类型断言" class="headerlink" title="Go语言的类型断言"></a>Go语言的类型断言</h3><p>golang中的所有程序都实现了interface{}的接口，这意味着，所有的类型如string,int,int64甚至是自定义的struct类型都就此拥有了interface{}的接口，这种做法和java中的Object类型比较类似。</p>
<p><strong>直接断言使用</strong></p>
<p>var a interface{}</p>
<p>fmt.Println(“Where are you,Jonny?”, a.(string))</p>
<p>但是如果断言失败一般会导致panic的发生。所以为了防止panic的发生，我们需要在断言前进行一定的判断</p>
<p>value, ok := a.(string)</p>
<p>如果断言失败，那么ok的值将会是false,但是如果断言成功ok的值将会是true,同时value将会得到所期待的正确的值。</p>
<p><strong>可以配合switch语句进行判断</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> t <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">t = functionOfSomeType()</span><br><span class="line"><span class="keyword">switch</span> t := t.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"unexpected type %T"</span>, t)       <span class="comment">// %T prints whatever type t has</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"boolean %t\n"</span>, t)             <span class="comment">// t has type bool</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"integer %d\n"</span>, t)             <span class="comment">// t has type int</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">bool</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"pointer to boolean %t\n"</span>, *t) <span class="comment">// t has type *bool</span></span><br><span class="line"><span class="keyword">case</span> *<span class="keyword">int</span>:</span><br><span class="line">    fmt.Printf(<span class="string">"pointer to integer %d\n"</span>, *t) <span class="comment">// t has type *int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Go语言编写可维护代码经验"><a href="#Go语言编写可维护代码经验" class="headerlink" title="Go语言编写可维护代码经验"></a>Go语言编写可维护代码经验</h3><p><strong>使用一致的声明风格</strong></p>
<p>Go 中至少有 6 种声明变量的方法</p>
<ul>
<li><code>var x int = 1</code></li>
<li><code>var x = 1</code></li>
<li><code>var x int; x = 1</code></li>
<li><code>var x = int(1)</code></li>
<li><code>x := 1</code></li>
</ul>
<p><strong>让零值变得有意义</strong></p>
<p>零值与其类型有关：数值类型为<code>0</code>，指针为<code>nil</code>，切片、映射、管道等也同样（为<code>nil</code>）</p>
<p><strong>通过 import 语句将代码整理到多个文件中</strong></p>
<p><strong>内部测试优于外部测试</strong></p>
<p>Go 工具集允许您在两处编写包的测试。假设您的包名是 <code>http2</code>，您可以使用 <code>package http2</code> 声明并编写一个 <code>http2_test.go</code> 文件，这样做将会把 <code>http2_test.go</code> 中的代码当成 http2 包的一部分编译进去。这通常称为<strong>内部</strong>测试。</p>
<p>Go 工具集同样支持一个以 test 结尾的特定声明的包，例如 <code>package http_test</code>，即使这些测试代码不会被视为正式代码一样编译到正式的包里，并且他们有自己独立的包名，也允许您的测试文件和源码文件一样放置在一起。这允许让您像在外部另外一个包里调用一样编写测试用例，这我们称之为<strong>外部</strong>测试。</p>
<p>在编写单元测试时我推荐使用内部测试。</p>
<p>您应该把 <code>Example</code> 测试函数放到外部测试中。这确保了在 godoc 中查看时，示例具有适当的包前缀，并且可以轻松地进行复制粘贴。</p>
<p><strong>不鼓励使用 <code>nil</code> 作为参数</strong></p>
<p><strong>首选可变参数（var args）而非切片参数（[]T）</strong></p>
<p>可变参数 rest …int</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Lin</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/07/12/go-%E5%AD%A6%E4%B9%A02/">http://yoursite.com/2020/07/12/go-%E5%AD%A6%E4%B9%A02/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Go/">Go</a></div><div class="post_share"><div class="social-share" data-image="/img/cat.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/07/13/java-JVM/"><img class="prev_cover lazyload" data-src="/img/cat.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">java JVM</div></div></a></div><div class="next-post pull_right"><a href="/2020/07/08/Go-Web/"><img class="next_cover lazyload" data-src="/img/cat.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Go-Web</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/05/25/go-学习/" title="go 学习"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-05-25</div><div class="relatedPosts_title">go 学习</div></div></a></div><div class="relatedPosts_item"><a href="/2020/07/08/Go-Web/" title="Go-Web"><img class="relatedPosts_cover lazyload"data-src="/img/cat.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-07-08</div><div class="relatedPosts_title">Go-Web</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> Comment</span></div><script id="utterances_comment" src="https://utteranc.es/client.js" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script><script>var themeNow = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
document.getElementById('utterances_comment').setAttribute('theme',themeNow)

function utterancesTheme () {
var theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
const message = {
  type: 'set-theme',
  theme: theme
};
const iframe = document.querySelector('.utterances-frame');
iframe.contentWindow.postMessage(message, 'https://utteranc.es');
}</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Lin</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="Read Mode"></i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion" target="_self">简</a><i class="darkmode fa fa-moon-o" id="darkmode" title="Dark Mode"></i></div><div id="rightside-config-show"><div id="rightside_config" title="Setting"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="Scroll to comment"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="Table of Contents" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="Back to top" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script></body></html>